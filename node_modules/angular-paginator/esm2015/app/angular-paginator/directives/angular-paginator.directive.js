/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Directive, Input, Output, EventEmitter, ChangeDetectorRef } from '@angular/core';
import { AngularPaginatorService } from '../services/angular-paginator.service';
import { Subject } from 'rxjs';
/**
 * This is the directive where the actual pagination takes place, it provides a sync between the
 * pipes and the pagination component
 */
export class AngularPaginatorDirective {
    /**
     *
     * @param {?} _angularPaginatorService serivce for angular paginator
     * @param {?} _changeDetectorRef for manual change detection
     */
    constructor(_angularPaginatorService, _changeDetectorRef) {
        this._angularPaginatorService = _angularPaginatorService;
        this._changeDetectorRef = _changeDetectorRef;
        this.firstPage = 1;
        this.pages = [];
        this.subscription = new Subject();
        /**
         * Emits an event whenever the current page is changed, It emits the current page number
         */
        this.pageChange = new EventEmitter(true);
        // subscribe to changes
        this.subscription = this._angularPaginatorService.change.subscribe(id => {
            if (id === this.id) {
                this.updatePages();
                this._changeDetectorRef.markForCheck();
            }
        });
    }
    /**
     * Navigate to prevoius page
     * @return {?}
     */
    toPreviousPage() {
        if (this.currentPage > this.firstPage) {
            this.setCurrentPage(this.currentPage - 1);
        }
        return;
    }
    /**
     * Navigate to next page
     * @return {?}
     */
    toNextPage() {
        if (this.currentPage < this.lastPage) {
            this.setCurrentPage(this.currentPage + 1);
        }
        return;
    }
    /**
     * Navigate to first page
     * @return {?}
     */
    toFirstPage() {
        this.setCurrentPage(this.firstPage);
        return;
    }
    /**
     * Navigate to last page
     * @return {?}
     */
    toLastPage() {
        this.setCurrentPage(this.lastPage);
        return;
    }
    /**
     * Sets current page
     *
     * @param {?} page page number to set as currentPage
     * @return {?}
     */
    setCurrentPage(page) {
        if (page && this.currentPage !== page) {
            this.currentPage = page;
            this.pageChange.emit(page);
        }
        return;
    }
    /**
     * create page object used for template
     *
     * @param {?} number page number
     * @param {?} text page number, text to be displayed
     * @param {?} isActive whether the page is active or not, true for currentPage
     * @return {?}
     */
    makePage(number, text, isActive) {
        return {
            number: number,
            text: text,
            active: isActive
        };
    }
    /**
     *  create page array
     *
     * @param {?} currentPage current page number
     * @param {?} itemsPerPage total items per page
     * @param {?} totalItems no of items for pagination, usually array length
     * @return {?}
     */
    getPages(currentPage, itemsPerPage, totalItems) {
        /** @type {?} */
        const pages = [];
        /** @type {?} */
        const totalPages = this.lastPage = Math.ceil(totalItems / itemsPerPage);
        /** @type {?} */
        let startPage = 1;
        /** @type {?} */
        let endPage = totalPages;
        /** @type {?} */
        const isMaxSized = this.maxSize && this.maxSize < totalPages;
        // recompute if maxSize
        if (isMaxSized) {
            if (this.rotate) {
                // current page is displayed in the middle of the visible ones
                startPage = Math.max(currentPage - Math.floor(this.maxSize / 2), 1);
                endPage = startPage + this.maxSize - 1;
                // Adjust if limit is exceeded
                if (endPage > totalPages) {
                    endPage = totalPages;
                    startPage = endPage - this.maxSize + 1;
                }
            }
            else {
                // Visible pages are paginated with maxSize
                startPage = (Math.ceil(currentPage / this.maxSize) - 1) * this.maxSize + 1;
                // adjust last page if limit is exceeded
                endPage = Math.min(startPage + this.maxSize - 1, totalPages);
            }
        }
        // add page number links
        for (let number = startPage; number <= endPage; number++) {
            /** @type {?} */
            const page = this.makePage(number, number, number === currentPage);
            pages.push(page);
        }
        // add links to move between page sets
        if (isMaxSized && this.maxSize > 0 && (!this.rotate || this.forceEllipses || this.boundaryLinkNumbers)) {
            if (startPage > 1) {
                if (!this.boundaryLinkNumbers || startPage > 3) { // need ellipsis for all options unless range is too close to beginning
                    /** @type {?} */
                    const previousPageSet = this.makePage(startPage - 1, '...', false);
                    pages.unshift(previousPageSet);
                }
                if (this.boundaryLinkNumbers) {
                    if (startPage === 3) { // need to replace ellipsis when the buttons would be sequential
                        /** @type {?} */
                        const secondPageLink = this.makePage(2, '2', false);
                        pages.unshift(secondPageLink);
                    }
                    /** @type {?} */
                    const firstPageLink = this.makePage(1, '1', false);
                    pages.unshift(firstPageLink);
                }
            }
            if (endPage < totalPages) {
                if (!this.boundaryLinkNumbers || endPage < totalPages - 2) { // need ellipsis for all options unless range is too close to end
                    /** @type {?} */
                    const nextPageSet = this.makePage(endPage + 1, '...', false);
                    pages.push(nextPageSet);
                }
                if (this.boundaryLinkNumbers) {
                    if (endPage === totalPages - 2) { // need to replace ellipsis when the buttons would be sequential
                        /** @type {?} */
                        const secondToLastPageLink = this.makePage(totalPages - 1, totalPages - 1, false);
                        pages.push(secondToLastPageLink);
                    }
                    /** @type {?} */
                    const lastPageLink = this.makePage(totalPages, totalPages, false);
                    pages.push(lastPageLink);
                }
            }
        }
        return pages;
    }
    /**
     * Updates the pagination component
     * @return {?}
     */
    updatePages() {
        /** @type {?} */
        const instance = this._angularPaginatorService.getInstance(this.id);
        /** @type {?} */
        const correctedCurrentPage = this.outOfBoundCorrection(instance);
        if (correctedCurrentPage !== instance['currentPage'] || this.currentPage !== instance['currentPage']) {
            this.setCurrentPage(correctedCurrentPage);
        }
        this.pages = this.getPages(instance.currentPage, instance.itemsPerPage, instance.totalItems);
        return;
    }
    /**
     * Check if currentPage is out of bound with totalPages
     *
     * @param {?} instance instance for which the range is to be corrected
     * @return {?}
     */
    outOfBoundCorrection(instance) {
        /** @type {?} */
        const totalPages = Math.ceil(instance['totalItems'] / instance['itemsPerPage']);
        if (totalPages < instance['currentPage'] && 0 < totalPages) {
            return totalPages;
        }
        else if (instance['currentPage'] < 1) {
            return 1;
        }
        return instance['currentPage'];
    }
    /**
     * check if there is any instance registered with the id
     * @return {?}
     */
    isValidId() {
        if (!this._angularPaginatorService.getInstance(this.id)) {
            throw new Error('There is no instance registered with id `' + this.id + '`');
        }
        return;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isValidId();
        this.updatePages();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        /** destroy the subscription when the directive is destroyed */
        this.subscription.unsubscribe();
    }
}
AngularPaginatorDirective.decorators = [
    { type: Directive, args: [{
                selector: 'appAngularPaginator, [appAngularPaginator]',
                exportAs: 'angularPaginator'
            },] }
];
/** @nocollapse */
AngularPaginatorDirective.ctorParameters = () => [
    { type: AngularPaginatorService },
    { type: ChangeDetectorRef }
];
AngularPaginatorDirective.propDecorators = {
    boundaryLinks: [{ type: Input }],
    directionLinks: [{ type: Input }],
    maxSize: [{ type: Input }],
    rotate: [{ type: Input }],
    boundaryLinkNumbers: [{ type: Input }],
    forceEllipses: [{ type: Input }],
    id: [{ type: Input }],
    pageChange: [{ type: Output }]
};
if (false) {
    /**
     * Whether to display First / Last buttons
     * @type {?}
     */
    AngularPaginatorDirective.prototype.boundaryLinks;
    /**
     * Whether to display Previous / Next buttons
     * @type {?}
     */
    AngularPaginatorDirective.prototype.directionLinks;
    /**
     * Limit number for pagination size, i.e., the maximum page numbers to be displayed
     * @type {?}
     */
    AngularPaginatorDirective.prototype.maxSize;
    /**
     * Whether to keep current page in the middle of the visible ones
     * @type {?}
     */
    AngularPaginatorDirective.prototype.rotate;
    /**
     * Whether to always display the first and last page numbers.
     * If max-size is smaller than the number of pages, then the first and last page numbers are still shown with ellipses
     * in-between as necessary. NOTE: max-size refers to the center of the range.
     * This option may add up to 2 more numbers on each side of the displayed range for the end value and
     * what would be an ellipsis but is replaced by a number because it is sequential
     * @type {?}
     */
    AngularPaginatorDirective.prototype.boundaryLinkNumbers;
    /**
     * Also displays ellipses when rotate is true and maxSize is smaller than the number of pages forceEllipses
     * @type {?}
     */
    AngularPaginatorDirective.prototype.forceEllipses;
    /**
     * Use unique id when multiple paginations are being used on the same page. By Default Paginator uses id `ANGULAR_PAGINATOR_DEFAULT`
     * @type {?}
     */
    AngularPaginatorDirective.prototype.id;
    /** @type {?} */
    AngularPaginatorDirective.prototype.currentPage;
    /** @type {?} */
    AngularPaginatorDirective.prototype.firstPage;
    /** @type {?} */
    AngularPaginatorDirective.prototype.lastPage;
    /** @type {?} */
    AngularPaginatorDirective.prototype.pages;
    /** @type {?} */
    AngularPaginatorDirective.prototype.subscription;
    /**
     * Emits an event whenever the current page is changed, It emits the current page number
     * @type {?}
     */
    AngularPaginatorDirective.prototype.pageChange;
    /** @type {?} */
    AngularPaginatorDirective.prototype._angularPaginatorService;
    /** @type {?} */
    AngularPaginatorDirective.prototype._changeDetectorRef;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1wYWdpbmF0b3IuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1wYWdpbmF0b3IvIiwic291cmNlcyI6WyJhcHAvYW5ndWxhci1wYWdpbmF0b3IvZGlyZWN0aXZlcy9hbmd1bGFyLXBhZ2luYXRvci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQXFCLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdHLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBRWhGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7Ozs7O0FBVy9CLE1BQU07Ozs7OztJQW9ESixZQUFvQix3QkFBaUQsRUFDM0Q7UUFEVSw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQXlCO1FBQzNELHVCQUFrQixHQUFsQixrQkFBa0I7eUJBakJoQixDQUFDO3FCQUVHLEVBQUU7NEJBRW1CLElBQUksT0FBTyxFQUFFOzs7OzBCQUtMLElBQUksWUFBWSxDQUFTLElBQUksQ0FBQzs7UUFXekUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUN0RSxJQUFJLEVBQUUsS0FBSyxJQUFJLENBQUMsRUFBRSxFQUFFO2dCQUNsQixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQ25CLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUN4QztTQUNGLENBQUMsQ0FBQztLQUVKOzs7OztJQUtELGNBQWM7UUFDWixJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNyQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUM7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QVksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO1FBRWhGLElBQUksVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxFQUFFO1lBQzFELE9BQU8sVUFBVSxDQUFDO1NBQ25CO2FBQU0sSUFBSSxRQUFRLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3RDLE9BQU8sQ0FBQyxDQUFDO1NBQ1Y7UUFFRCxPQUFPLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztLQUNoQzs7Ozs7SUFLRCxTQUFTO1FBRVAsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ3ZELE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUM5RTtRQUVELE9BQU87S0FDUjs7OztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDakIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3BCOzs7O0lBRUQsV0FBVzs7UUFFVCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ2pDOzs7WUF4UkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSw0Q0FBNEM7Z0JBQ3RELFFBQVEsRUFBRSxrQkFBa0I7YUFDN0I7Ozs7WUFYUSx1QkFBdUI7WUFEb0MsaUJBQWlCOzs7NEJBbUJsRixLQUFLOzZCQUlMLEtBQUs7c0JBSUwsS0FBSztxQkFJTCxLQUFLO2tDQVFMLEtBQUs7NEJBSUwsS0FBSztpQkFJTCxLQUFLO3lCQVlMLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIE9uSW5pdCwgT25EZXN0cm95LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENoYW5nZURldGVjdG9yUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbmd1bGFyUGFnaW5hdG9yU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuZ3VsYXItcGFnaW5hdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQW5ndWxhclBhZ2luYXRvckluc3RhbmNlLCBQYWdlIH0gZnJvbSAnLi4vb3RoZXJzL2FuZ3VsYXItcGFnaW5hdG9yLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZGlyZWN0aXZlIHdoZXJlIHRoZSBhY3R1YWwgcGFnaW5hdGlvbiB0YWtlcyBwbGFjZSwgaXQgcHJvdmlkZXMgYSBzeW5jIGJldHdlZW4gdGhlXG4gKiBwaXBlcyBhbmQgdGhlIHBhZ2luYXRpb24gY29tcG9uZW50XG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2FwcEFuZ3VsYXJQYWdpbmF0b3IsIFthcHBBbmd1bGFyUGFnaW5hdG9yXScsXG4gIGV4cG9ydEFzOiAnYW5ndWxhclBhZ2luYXRvcidcbn0pXG5cbmV4cG9ydCBjbGFzcyBBbmd1bGFyUGFnaW5hdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRpc3BsYXkgRmlyc3QgLyBMYXN0IGJ1dHRvbnNcbiAgICovXG4gIEBJbnB1dCgpIGJvdW5kYXJ5TGlua3M6IGJvb2xlYW47XG4gIC8qKlxuICAqIFdoZXRoZXIgdG8gZGlzcGxheSBQcmV2aW91cyAvIE5leHQgYnV0dG9uc1xuICAqL1xuICBASW5wdXQoKSBkaXJlY3Rpb25MaW5rczogYm9vbGVhbjtcbiAgLyoqXG4gICAqIExpbWl0IG51bWJlciBmb3IgcGFnaW5hdGlvbiBzaXplLCBpLmUuLCB0aGUgbWF4aW11bSBwYWdlIG51bWJlcnMgdG8gYmUgZGlzcGxheWVkXG4gICAqL1xuICBASW5wdXQoKSBtYXhTaXplOiBudW1iZXI7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGtlZXAgY3VycmVudCBwYWdlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xuICAgKi9cbiAgQElucHV0KCkgcm90YXRlOiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0byBhbHdheXMgZGlzcGxheSB0aGUgZmlyc3QgYW5kIGxhc3QgcGFnZSBudW1iZXJzLlxuICAgKiBJZiBtYXgtc2l6ZSBpcyBzbWFsbGVyIHRoYW4gdGhlIG51bWJlciBvZiBwYWdlcywgdGhlbiB0aGUgZmlyc3QgYW5kIGxhc3QgcGFnZSBudW1iZXJzIGFyZSBzdGlsbCBzaG93biB3aXRoIGVsbGlwc2VzXG4gICAqIGluLWJldHdlZW4gYXMgbmVjZXNzYXJ5LiBOT1RFOiBtYXgtc2l6ZSByZWZlcnMgdG8gdGhlIGNlbnRlciBvZiB0aGUgcmFuZ2UuXG4gICAqIFRoaXMgb3B0aW9uIG1heSBhZGQgdXAgdG8gMiBtb3JlIG51bWJlcnMgb24gZWFjaCBzaWRlIG9mIHRoZSBkaXNwbGF5ZWQgcmFuZ2UgZm9yIHRoZSBlbmQgdmFsdWUgYW5kXG4gICAqIHdoYXQgd291bGQgYmUgYW4gZWxsaXBzaXMgYnV0IGlzIHJlcGxhY2VkIGJ5IGEgbnVtYmVyIGJlY2F1c2UgaXQgaXMgc2VxdWVudGlhbFxuICAgKi9cbiAgQElucHV0KCkgYm91bmRhcnlMaW5rTnVtYmVyczogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFsc28gZGlzcGxheXMgZWxsaXBzZXMgd2hlbiByb3RhdGUgaXMgdHJ1ZSBhbmQgbWF4U2l6ZSBpcyBzbWFsbGVyIHRoYW4gdGhlIG51bWJlciBvZiBwYWdlcyBmb3JjZUVsbGlwc2VzXG4gICAqL1xuICBASW5wdXQoKSBmb3JjZUVsbGlwc2VzOiBib29sZWFuO1xuICAvKipcbiAgICogVXNlIHVuaXF1ZSBpZCB3aGVuIG11bHRpcGxlIHBhZ2luYXRpb25zIGFyZSBiZWluZyB1c2VkIG9uIHRoZSBzYW1lIHBhZ2UuIEJ5IERlZmF1bHQgUGFnaW5hdG9yIHVzZXMgaWQgYEFOR1VMQVJfUEFHSU5BVE9SX0RFRkFVTFRgXG4gICAqL1xuICBASW5wdXQoKSBpZDogc3RyaW5nO1xuXG4gIGN1cnJlbnRQYWdlOiBudW1iZXI7XG4gIGZpcnN0UGFnZSA9IDE7XG4gIGxhc3RQYWdlOiBudW1iZXI7XG4gIHBhZ2VzOiBQYWdlW10gPSBbXTtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgcGFnZSBpcyBjaGFuZ2VkLCBJdCBlbWl0cyB0aGUgY3VycmVudCBwYWdlIG51bWJlclxuICAgKi9cbiAgQE91dHB1dCgpIHBhZ2VDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KHRydWUpO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlIHNlcml2Y2UgZm9yIGFuZ3VsYXIgcGFnaW5hdG9yXG4gICAqIEBwYXJhbSBfY2hhbmdlRGV0ZWN0b3JSZWYgZm9yIG1hbnVhbCBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9hbmd1bGFyUGFnaW5hdG9yU2VydmljZTogQW5ndWxhclBhZ2luYXRvclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5fYW5ndWxhclBhZ2luYXRvclNlcnZpY2UuY2hhbmdlLnN1YnNjcmliZShpZCA9PiB7XG4gICAgICBpZiAoaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYWdlcygpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHByZXZvaXVzIHBhZ2VcbiAgICovXG4gIHRvUHJldmlvdXNQYWdlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlID4gdGhpcy5maXJzdFBhZ2UpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UodGhpcy5jdXJyZW50UGFnZSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gbmV4dCBwYWdlXG4gICAqL1xuICB0b05leHRQYWdlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlIDwgdGhpcy5sYXN0UGFnZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UGFnZSh0aGlzLmN1cnJlbnRQYWdlICsgMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byBmaXJzdCBwYWdlXG4gICAqL1xuICB0b0ZpcnN0UGFnZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNldEN1cnJlbnRQYWdlKHRoaXMuZmlyc3RQYWdlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gbGFzdCBwYWdlXG4gICAqL1xuICB0b0xhc3RQYWdlKCk6IHZvaWQge1xuICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UodGhpcy5sYXN0UGFnZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgY3VycmVudCBwYWdlXG4gICAqXG4gICAqIEBwYXJhbSBwYWdlIHBhZ2UgbnVtYmVyIHRvIHNldCBhcyBjdXJyZW50UGFnZVxuICAgKi9cbiAgc2V0Q3VycmVudFBhZ2UocGFnZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHBhZ2UgJiYgdGhpcy5jdXJyZW50UGFnZSAhPT0gcGFnZSkge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdChwYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBwYWdlIG9iamVjdCB1c2VkIGZvciB0ZW1wbGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gbnVtYmVyIHBhZ2UgbnVtYmVyXG4gICAqIEBwYXJhbSB0ZXh0IHBhZ2UgbnVtYmVyLCB0ZXh0IHRvIGJlIGRpc3BsYXllZFxuICAgKiBAcGFyYW0gaXNBY3RpdmUgd2hldGhlciB0aGUgcGFnZSBpcyBhY3RpdmUgb3Igbm90LCB0cnVlIGZvciBjdXJyZW50UGFnZVxuICAgKi9cbiAgbWFrZVBhZ2UobnVtYmVyOiBudW1iZXIsIHRleHQ6IGFueSwgaXNBY3RpdmU6IGJvb2xlYW4pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBhY3RpdmU6IGlzQWN0aXZlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgY3JlYXRlIHBhZ2UgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIGN1cnJlbnRQYWdlIGN1cnJlbnQgcGFnZSBudW1iZXJcbiAgICogQHBhcmFtIGl0ZW1zUGVyUGFnZSB0b3RhbCBpdGVtcyBwZXIgcGFnZVxuICAgKiBAcGFyYW0gdG90YWxJdGVtcyBubyBvZiBpdGVtcyBmb3IgcGFnaW5hdGlvbiwgdXN1YWxseSBhcnJheSBsZW5ndGhcbiAgICovXG4gIGdldFBhZ2VzKGN1cnJlbnRQYWdlOiBudW1iZXIsIGl0ZW1zUGVyUGFnZTogbnVtYmVyLCB0b3RhbEl0ZW1zOiBudW1iZXIpOiBhbnkge1xuICAgIGNvbnN0IHBhZ2VzOiBhbnkgPSBbXTtcblxuICAgIC8vIERlZmF1bHQgcGFnZSBsaW1pdHNcbiAgICBjb25zdCB0b3RhbFBhZ2VzOiBudW1iZXIgPSB0aGlzLmxhc3RQYWdlID0gTWF0aC5jZWlsKHRvdGFsSXRlbXMgLyBpdGVtc1BlclBhZ2UpO1xuXG4gICAgbGV0IHN0YXJ0UGFnZSA9IDE7XG4gICAgbGV0IGVuZFBhZ2U6IG51bWJlciA9IHRvdGFsUGFnZXM7XG4gICAgY29uc3QgaXNNYXhTaXplZDogYm9vbGVhbiA9IHRoaXMubWF4U2l6ZSAmJiB0aGlzLm1heFNpemUgPCB0b3RhbFBhZ2VzO1xuXG4gICAgLy8gcmVjb21wdXRlIGlmIG1heFNpemVcbiAgICBpZiAoaXNNYXhTaXplZCkge1xuXG4gICAgICBpZiAodGhpcy5yb3RhdGUpIHtcblxuICAgICAgICAvLyBjdXJyZW50IHBhZ2UgaXMgZGlzcGxheWVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xuICAgICAgICBzdGFydFBhZ2UgPSBNYXRoLm1heChjdXJyZW50UGFnZSAtIE1hdGguZmxvb3IodGhpcy5tYXhTaXplIC8gMiksIDEpO1xuICAgICAgICBlbmRQYWdlID0gc3RhcnRQYWdlICsgdGhpcy5tYXhTaXplIC0gMTtcblxuICAgICAgICAvLyBBZGp1c3QgaWYgbGltaXQgaXMgZXhjZWVkZWRcbiAgICAgICAgaWYgKGVuZFBhZ2UgPiB0b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgICAgICAgc3RhcnRQYWdlID0gZW5kUGFnZSAtIHRoaXMubWF4U2l6ZSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFZpc2libGUgcGFnZXMgYXJlIHBhZ2luYXRlZCB3aXRoIG1heFNpemVcbiAgICAgICAgc3RhcnRQYWdlID0gKE1hdGguY2VpbChjdXJyZW50UGFnZSAvIHRoaXMubWF4U2l6ZSkgLSAxKSAqIHRoaXMubWF4U2l6ZSArIDE7XG5cbiAgICAgICAgLy8gYWRqdXN0IGxhc3QgcGFnZSBpZiBsaW1pdCBpcyBleGNlZWRlZFxuICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oc3RhcnRQYWdlICsgdGhpcy5tYXhTaXplIC0gMSwgdG90YWxQYWdlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHBhZ2UgbnVtYmVyIGxpbmtzXG4gICAgZm9yIChsZXQgbnVtYmVyID0gc3RhcnRQYWdlOyBudW1iZXIgPD0gZW5kUGFnZTsgbnVtYmVyKyspIHtcbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLm1ha2VQYWdlKG51bWJlciwgbnVtYmVyLCBudW1iZXIgPT09IGN1cnJlbnRQYWdlKTtcbiAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGxpbmtzIHRvIG1vdmUgYmV0d2VlbiBwYWdlIHNldHNcbiAgICBpZiAoaXNNYXhTaXplZCAmJiB0aGlzLm1heFNpemUgPiAwICYmICghdGhpcy5yb3RhdGUgfHwgdGhpcy5mb3JjZUVsbGlwc2VzIHx8IHRoaXMuYm91bmRhcnlMaW5rTnVtYmVycykpIHtcbiAgICAgIGlmIChzdGFydFBhZ2UgPiAxKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJvdW5kYXJ5TGlua051bWJlcnMgfHwgc3RhcnRQYWdlID4gMykgeyAvLyBuZWVkIGVsbGlwc2lzIGZvciBhbGwgb3B0aW9ucyB1bmxlc3MgcmFuZ2UgaXMgdG9vIGNsb3NlIHRvIGJlZ2lubmluZ1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGFnZVNldCA9IHRoaXMubWFrZVBhZ2Uoc3RhcnRQYWdlIC0gMSwgJy4uLicsIGZhbHNlKTtcbiAgICAgICAgICBwYWdlcy51bnNoaWZ0KHByZXZpb3VzUGFnZVNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ib3VuZGFyeUxpbmtOdW1iZXJzKSB7XG5cbiAgICAgICAgICBpZiAoc3RhcnRQYWdlID09PSAzKSB7IC8vIG5lZWQgdG8gcmVwbGFjZSBlbGxpcHNpcyB3aGVuIHRoZSBidXR0b25zIHdvdWxkIGJlIHNlcXVlbnRpYWxcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFBhZ2VMaW5rID0gdGhpcy5tYWtlUGFnZSgyLCAnMicsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoc2Vjb25kUGFnZUxpbmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgIGNvbnN0IGZpcnN0UGFnZUxpbmsgPSB0aGlzLm1ha2VQYWdlKDEsICcxJywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoZmlyc3RQYWdlTGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFBhZ2UgPCB0b3RhbFBhZ2VzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJvdW5kYXJ5TGlua051bWJlcnMgfHwgZW5kUGFnZSA8IHRvdGFsUGFnZXMgLSAyKSB7IC8vIG5lZWQgZWxsaXBzaXMgZm9yIGFsbCBvcHRpb25zIHVubGVzcyByYW5nZSBpcyB0b28gY2xvc2UgdG8gZW5kXG4gICAgICAgICAgY29uc3QgbmV4dFBhZ2VTZXQgPSB0aGlzLm1ha2VQYWdlKGVuZFBhZ2UgKyAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnB1c2gobmV4dFBhZ2VTZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYm91bmRhcnlMaW5rTnVtYmVycykge1xuXG4gICAgICAgICAgaWYgKGVuZFBhZ2UgPT09IHRvdGFsUGFnZXMgLSAyKSB7IC8vIG5lZWQgdG8gcmVwbGFjZSBlbGxpcHNpcyB3aGVuIHRoZSBidXR0b25zIHdvdWxkIGJlIHNlcXVlbnRpYWxcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFRvTGFzdFBhZ2VMaW5rID0gdGhpcy5tYWtlUGFnZSh0b3RhbFBhZ2VzIC0gMSwgdG90YWxQYWdlcyAtIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhZ2VzLnB1c2goc2Vjb25kVG9MYXN0UGFnZUxpbmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCB0aGUgbGFzdCBwYWdlXG4gICAgICAgICAgY29uc3QgbGFzdFBhZ2VMaW5rID0gdGhpcy5tYWtlUGFnZSh0b3RhbFBhZ2VzLCB0b3RhbFBhZ2VzLCBmYWxzZSk7XG4gICAgICAgICAgcGFnZXMucHVzaChsYXN0UGFnZUxpbmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwYWdpbmF0aW9uIGNvbXBvbmVudFxuICAgKi9cbiAgdXBkYXRlUGFnZXMoKTogdm9pZCB7XG4gICAgY29uc3QgaW5zdGFuY2U6IEFuZ3VsYXJQYWdpbmF0b3JJbnN0YW5jZSA9IHRoaXMuX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuaWQpO1xuXG4gICAgY29uc3QgY29ycmVjdGVkQ3VycmVudFBhZ2UgPSB0aGlzLm91dE9mQm91bmRDb3JyZWN0aW9uKGluc3RhbmNlKTtcblxuICAgIGlmIChjb3JyZWN0ZWRDdXJyZW50UGFnZSAhPT0gaW5zdGFuY2VbJ2N1cnJlbnRQYWdlJ10gfHwgdGhpcy5jdXJyZW50UGFnZSAhPT0gaW5zdGFuY2VbJ2N1cnJlbnRQYWdlJ10pIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UoY29ycmVjdGVkQ3VycmVudFBhZ2UpO1xuICAgIH1cblxuICAgIHRoaXMucGFnZXMgPSB0aGlzLmdldFBhZ2VzKGluc3RhbmNlLmN1cnJlbnRQYWdlLCBpbnN0YW5jZS5pdGVtc1BlclBhZ2UsIGluc3RhbmNlLnRvdGFsSXRlbXMpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGN1cnJlbnRQYWdlIGlzIG91dCBvZiBib3VuZCB3aXRoIHRvdGFsUGFnZXNcbiAgICpcbiAgICogQHBhcmFtIGluc3RhbmNlIGluc3RhbmNlIGZvciB3aGljaCB0aGUgcmFuZ2UgaXMgdG8gYmUgY29ycmVjdGVkXG4gICAqL1xuICBvdXRPZkJvdW5kQ29ycmVjdGlvbihpbnN0YW5jZTogQW5ndWxhclBhZ2luYXRvckluc3RhbmNlKTogbnVtYmVyIHtcblxuICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwoaW5zdGFuY2VbJ3RvdGFsSXRlbXMnXSAvIGluc3RhbmNlWydpdGVtc1BlclBhZ2UnXSk7XG5cbiAgICBpZiAodG90YWxQYWdlcyA8IGluc3RhbmNlWydjdXJyZW50UGFnZSddICYmIDAgPCB0b3RhbFBhZ2VzKSB7XG4gICAgICByZXR1cm4gdG90YWxQYWdlcztcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlWydjdXJyZW50UGFnZSddIDwgMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlWydjdXJyZW50UGFnZSddO1xuICB9XG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIHRoZXJlIGlzIGFueSBpbnN0YW5jZSByZWdpc3RlcmVkIHdpdGggdGhlIGlkXG4gICAqL1xuICBpc1ZhbGlkSWQoKTogdm9pZCB7XG5cbiAgICBpZiAoIXRoaXMuX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGluc3RhbmNlIHJlZ2lzdGVyZWQgd2l0aCBpZCBgJyArIHRoaXMuaWQgKyAnYCcpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuaXNWYWxpZElkKCk7XG4gICAgdGhpcy51cGRhdGVQYWdlcygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgLyoqIGRlc3Ryb3kgdGhlIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBkaXJlY3RpdmUgaXMgZGVzdHJveWVkICovXG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG59XG4iXX0=