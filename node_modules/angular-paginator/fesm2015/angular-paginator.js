import { Injectable, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, Pipe, Directive, ChangeDetectorRef, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AngularPaginatorService {
    constructor() {
        /**
         * id is used to identify pagination instances
         */
        this.id = 'ANGULAR_PAGINATOR_DEFAULT';
        /**
         * instances is the collection of pagination componetns
         */
        this.instances = {};
        /**
         * emits an event with instance id whenever the page number changes
         */
        this.change = new EventEmitter();
    }
    /**
     * creates an instance for every pipe differentiated with id
     *
     * @param {?} instance each instance refers to a unique pagination component
     * @return {?}
     */
    registerInstance(instance) {
        if (!this.instances[instance.id]) {
            this.instances[instance.id] = instance;
            this.change.emit(instance.id);
        }
        else {
            /** @type {?} */
            const changed = this.updateInstance(instance);
            if (changed) {
                this.change.emit(instance.id);
            }
        }
        return;
    }
    /**
     * updates existing pagination instances available
     * and returns true if value has changed
     *
     * @param {?} instance an unique pagination component
     * @return {?}
     */
    updateInstance(instance) {
        for (const key in instance) {
            if (instance[key] !== this.instances[instance['id']][key]) {
                this.instances[instance['id']][key] = instance[key];
                return true;
            }
        }
        return false;
    }
    /**
     * return instance with given id
     *
     * @param {?} id unique id of the pagination component
     * @return {?}
     */
    getInstance(id) {
        return this.instances[id];
    }
    /**
     * return currentPage for given id
     *
     * @param {?} id unique id of the pagination component
     * @return {?}
     */
    getCurrentPage(id) {
        return this.instances[id].currentPage;
    }
}
AngularPaginatorService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AngularPaginatorService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * The component that renders the Pagination component template, It also accepts the inputs for the Pagination component
 */
class AngularPaginatorComponent {
    /**
     *
     * @param {?} _angularPaginatorService service for angular paginator
     */
    constructor(_angularPaginatorService) {
        this._angularPaginatorService = _angularPaginatorService;
        /**
         * Whether to display First / Last buttons
         */
        this.boundaryLinks = false;
        /**
         * Whether to display Previous / Next buttons
         */
        this.directionLinks = true;
        /**
         * Limit number for pagination size, i.e., the maximum page numbers to be displayed
         */
        this.maxSize = 5;
        /**
         * Whether to keep current page in the middle of the visible ones
         */
        this.rotate = true;
        /**
         * Whether to always display the first and last page numbers.
         * If max-size is smaller than the number of pages, then the first and last page numbers are still shown with ellipses
         * in-between as necessary. NOTE: max-size refers to the center of the range.
         * This option may add up to 2 more numbers on each side of the displayed range for the end value and
         * what would be an ellipsis but is replaced by a number because it is sequential
         */
        this.boundaryLinkNumbers = false;
        /**
         * Also displays ellipses when rotate is true and maxSize is smaller than the number of pages forceEllipses
         */
        this.forceEllipses = false;
        /**
         * Text for first button
         */
        this.firstText = 'First';
        /**
         * Text for previous button
         */
        this.previousText = 'Previous';
        /**
         * Text for next button
         */
        this.nextText = 'Next';
        /**
         * Text for last button
         */
        this.lastText = 'Last';
        /**
         * Screen reader text for first button
         */
        this.screenReaderFirstText = 'First';
        /**
         * Screen reader text for previous button
         */
        this.screenReaderPreviousText = 'Previous';
        /**
         * Screen reader text for next button
         */
        this.screenReaderNextText = 'Next';
        /**
         * Screen reader text for lasr button
         */
        this.screenReaderLastText = 'Last';
        /**
         * Screen reader text for page numbers
         */
        this.screenReaderPageText = 'Page';
        /**
         * Screen reader text for current page
         */
        this.screenReaderCurrentPageText = 'You`re on page';
        /**
         * Screen reader text for the pagination component
         */
        this.screenReaderPaginationLabel = 'Pagination';
        /**
         * Hides the pagination component if the items are less than `itemsPerPage`
         */
        this.autoHide = false;
        /**
         * disables pagination component
         */
        this.disabled = false;
        /**
         * Emits an event whenever the current page is changed, It emits the current page number
         *
         * This event is originally picked up from `AngularPaginatorDirective`
         */
        this.pageChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // set default id if not provided
        this.id = this.id ? this.id : this._angularPaginatorService.id;
        // set default class if not provided
        this.className = this.className ? this.className : this._angularPaginatorService.id;
    }
}
AngularPaginatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-angular-paginator',
                template: "<appAngularPaginator [id]=\"id\" [boundaryLinks]=\"boundaryLinks\" [directionLinks]=\"directionLinks\" [maxSize]=\"maxSize\"\n  [rotate]=\"rotate\" [boundaryLinkNumbers]=\"boundaryLinkNumbers\" [forceEllipses]=\"forceEllipses\" #paginator=\"angularPaginator\"\n  (pageChange)=\"pageChange.emit($event)\">\n\n  <!-- ======================================== BOOTSTRAP 4 TEMPLATE ======================================== -->\n  <ng-container *ngIf=\"!(autoHide && paginator.pages['length'] <= 1)\">\n    <nav class=\"angular-bs4-pagination\" [attr.aria-label]=\"screenReaderPaginationLabel\">\n\n      <ng-container *ngIf=\"paginator.pages['length'] !== 0\">\n        <ul class=\"pagination\" [ngClass]=\"className\">\n\n          <!-- boundary link -->\n          <li class=\"page-item\" *ngIf=\"boundaryLinks\" (click)=\"paginator.toFirstPage()\" [ngClass]=\"{'disabled': (paginator.currentPage === paginator.firstPage) || disabled}\">\n            <a class=\"page-link\" href=\"javascript:void(0)\">\n              <span aria-hidden=\"true\" [innerHTML]=\"firstText\"></span>\n              <span class=\"sr-only\">{{ screenReaderFirstText }}</span>\n            </a>\n          </li>\n\n          <!-- direction link -->\n          <li class=\"page-item\" *ngIf=\"directionLinks\" (click)=\"paginator.toPreviousPage()\" [ngClass]=\"{'disabled': (paginator.currentPage === paginator.firstPage) || disabled}\">\n            <a class=\"page-link\" href=\"javascript:void(0)\">\n              <span aria-hidden=\"true\" [innerHTML]=\"previousText\"></span>\n              <span class=\"sr-only\">{{ screenReaderPreviousText }}</span>\n            </a>\n          </li>\n\n          <!-- pagination array -->\n          <li class=\"page-item\" *ngFor=\"let page of paginator.pages\" [ngClass]=\"{'active': page['active'], 'disabled': disabled}\"\n            (click)=\"!page['active'] && paginator.setCurrentPage(page['number'])\">\n            <a href=\"javascript:void(0)\" class=\"page-link\">\n              {{ page['text'] }}\n              <span class=\"sr-only\" *ngIf=\"!page['active']\">{{ screenReaderPageText + ' ' }}{{ page['text'] }}</span>\n              <span class=\"sr-only\" *ngIf=\"page['active']\">{{ screenReaderCurrentPageText + ' ' }}{{ page['text'] }}</span>\n            </a>\n          </li>\n\n          <!-- direction link -->\n          <li class=\"page-item\" *ngIf=\"directionLinks\" (click)=\"paginator.toNextPage()\" [ngClass]=\"{'disabled': (paginator.currentPage === paginator.lastPage) || disabled}\">\n            <a class=\"page-link\" href=\"javascript:void(0)\">\n              <span aria-hidden=\"true\" [innerHTML]=\"nextText\"></span>\n              <span class=\"sr-only\">{{ screenReaderNextText }}</span>\n            </a>\n          </li>\n\n          <!-- boundary link -->\n          <li class=\"page-item\" *ngIf=\"boundaryLinks\" (click)=\"paginator.toLastPage()\" [ngClass]=\"{'disabled': (paginator.currentPage === paginator.lastPage) || disabled}\">\n            <a class=\"page-link\" href=\"javascript:void(0)\">\n              <span aria-hidden=\"true\" [innerHTML]=\"lastText\"></span>\n              <span class=\"sr-only\">{{ screenReaderLastText }}</span>\n            </a>\n          </li>\n\n        </ul>\n      </ng-container>\n\n    </nav>\n  </ng-container>\n\n</appAngularPaginator>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".angular-bs4-pagination .disabled{pointer-events:none}"]
            }] }
];
/** @nocollapse */
AngularPaginatorComponent.ctorParameters = () => [
    { type: AngularPaginatorService }
];
AngularPaginatorComponent.propDecorators = {
    boundaryLinks: [{ type: Input }],
    directionLinks: [{ type: Input }],
    maxSize: [{ type: Input }],
    rotate: [{ type: Input }],
    boundaryLinkNumbers: [{ type: Input }],
    forceEllipses: [{ type: Input }],
    id: [{ type: Input }],
    firstText: [{ type: Input }],
    previousText: [{ type: Input }],
    nextText: [{ type: Input }],
    lastText: [{ type: Input }],
    screenReaderFirstText: [{ type: Input }],
    screenReaderPreviousText: [{ type: Input }],
    screenReaderNextText: [{ type: Input }],
    screenReaderLastText: [{ type: Input }],
    screenReaderPageText: [{ type: Input }],
    screenReaderCurrentPageText: [{ type: Input }],
    screenReaderPaginationLabel: [{ type: Input }],
    className: [{ type: Input }],
    autoHide: [{ type: Input }],
    disabled: [{ type: Input }],
    pageChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Pagination Pipe which paginates the array for the provided arguments such as `itemsPerPage` and `currentPage`
 */
class AngularPaginatorPipe {
    /**
     *
     * @param {?} _angularPaginatorService service for angular pagiantor
     */
    constructor(_angularPaginatorService) {
        this._angularPaginatorService = _angularPaginatorService;
    }
    /**
     * this pipes paginates the array for the provided arguments such as `itemsPerPage` and `currentPage`
     *
     * @param {?} array input array for which the manipulation happens
     * @param {?=} args input arguments for the paginator pipe
     * @return {?}
     */
    transform(array, args) {
        /** @type {?} */
        const instance = this.createInstance(array, args);
        // create pagination information
        this._angularPaginatorService.registerInstance(instance);
        /** @type {?} */
        const start = (instance.currentPage - 1) * instance.itemsPerPage;
        /** @type {?} */
        const end = instance.currentPage * instance.itemsPerPage;
        return array.slice(start, end);
    }
    /**
     * create an instance for each pipe
     *
     * @param {?} array input array for which the manipulation happens
     * @param {?} args input arguments for the paginator pipe
     * @return {?}
     */
    createInstance(array, args) {
        return {
            id: args['id'] ? args.id : this._angularPaginatorService.id,
            currentPage: args['currentPage'] ? args['currentPage'] : 1,
            itemsPerPage: args['itemsPerPage'] ? args['itemsPerPage'] : 10,
            totalItems: array['length']
        };
    }
}
AngularPaginatorPipe.decorators = [
    { type: Pipe, args: [{
                name: 'angularPaginator'
            },] }
];
/** @nocollapse */
AngularPaginatorPipe.ctorParameters = () => [
    { type: AngularPaginatorService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This is the directive where the actual pagination takes place, it provides a sync between the
 * pipes and the pagination component
 */
class AngularPaginatorDirective {
    /**
     *
     * @param {?} _angularPaginatorService serivce for angular paginator
     * @param {?} _changeDetectorRef for manual change detection
     */
    constructor(_angularPaginatorService, _changeDetectorRef) {
        this._angularPaginatorService = _angularPaginatorService;
        this._changeDetectorRef = _changeDetectorRef;
        this.firstPage = 1;
        this.pages = [];
        this.subscription = new Subject();
        /**
         * Emits an event whenever the current page is changed, It emits the current page number
         */
        this.pageChange = new EventEmitter(true);
        // subscribe to changes
        this.subscription = this._angularPaginatorService.change.subscribe(id => {
            if (id === this.id) {
                this.updatePages();
                this._changeDetectorRef.markForCheck();
            }
        });
    }
    /**
     * Navigate to prevoius page
     * @return {?}
     */
    toPreviousPage() {
        if (this.currentPage > this.firstPage) {
            this.setCurrentPage(this.currentPage - 1);
        }
        return;
    }
    /**
     * Navigate to next page
     * @return {?}
     */
    toNextPage() {
        if (this.currentPage < this.lastPage) {
            this.setCurrentPage(this.currentPage + 1);
        }
        return;
    }
    /**
     * Navigate to first page
     * @return {?}
     */
    toFirstPage() {
        this.setCurrentPage(this.firstPage);
        return;
    }
    /**
     * Navigate to last page
     * @return {?}
     */
    toLastPage() {
        this.setCurrentPage(this.lastPage);
        return;
    }
    /**
     * Sets current page
     *
     * @param {?} page page number to set as currentPage
     * @return {?}
     */
    setCurrentPage(page) {
        if (page && this.currentPage !== page) {
            this.currentPage = page;
            this.pageChange.emit(page);
        }
        return;
    }
    /**
     * create page object used for template
     *
     * @param {?} number page number
     * @param {?} text page number, text to be displayed
     * @param {?} isActive whether the page is active or not, true for currentPage
     * @return {?}
     */
    makePage(number, text, isActive) {
        return {
            number: number,
            text: text,
            active: isActive
        };
    }
    /**
     *  create page array
     *
     * @param {?} currentPage current page number
     * @param {?} itemsPerPage total items per page
     * @param {?} totalItems no of items for pagination, usually array length
     * @return {?}
     */
    getPages(currentPage, itemsPerPage, totalItems) {
        /** @type {?} */
        const pages = [];
        /** @type {?} */
        const totalPages = this.lastPage = Math.ceil(totalItems / itemsPerPage);
        /** @type {?} */
        let startPage = 1;
        /** @type {?} */
        let endPage = totalPages;
        /** @type {?} */
        const isMaxSized = this.maxSize && this.maxSize < totalPages;
        // recompute if maxSize
        if (isMaxSized) {
            if (this.rotate) {
                // current page is displayed in the middle of the visible ones
                startPage = Math.max(currentPage - Math.floor(this.maxSize / 2), 1);
                endPage = startPage + this.maxSize - 1;
                // Adjust if limit is exceeded
                if (endPage > totalPages) {
                    endPage = totalPages;
                    startPage = endPage - this.maxSize + 1;
                }
            }
            else {
                // Visible pages are paginated with maxSize
                startPage = (Math.ceil(currentPage / this.maxSize) - 1) * this.maxSize + 1;
                // adjust last page if limit is exceeded
                endPage = Math.min(startPage + this.maxSize - 1, totalPages);
            }
        }
        // add page number links
        for (let number = startPage; number <= endPage; number++) {
            /** @type {?} */
            const page = this.makePage(number, number, number === currentPage);
            pages.push(page);
        }
        // add links to move between page sets
        if (isMaxSized && this.maxSize > 0 && (!this.rotate || this.forceEllipses || this.boundaryLinkNumbers)) {
            if (startPage > 1) {
                if (!this.boundaryLinkNumbers || startPage > 3) { // need ellipsis for all options unless range is too close to beginning
                    /** @type {?} */
                    const previousPageSet = this.makePage(startPage - 1, '...', false);
                    pages.unshift(previousPageSet);
                }
                if (this.boundaryLinkNumbers) {
                    if (startPage === 3) { // need to replace ellipsis when the buttons would be sequential
                        /** @type {?} */
                        const secondPageLink = this.makePage(2, '2', false);
                        pages.unshift(secondPageLink);
                    }
                    /** @type {?} */
                    const firstPageLink = this.makePage(1, '1', false);
                    pages.unshift(firstPageLink);
                }
            }
            if (endPage < totalPages) {
                if (!this.boundaryLinkNumbers || endPage < totalPages - 2) { // need ellipsis for all options unless range is too close to end
                    /** @type {?} */
                    const nextPageSet = this.makePage(endPage + 1, '...', false);
                    pages.push(nextPageSet);
                }
                if (this.boundaryLinkNumbers) {
                    if (endPage === totalPages - 2) { // need to replace ellipsis when the buttons would be sequential
                        /** @type {?} */
                        const secondToLastPageLink = this.makePage(totalPages - 1, totalPages - 1, false);
                        pages.push(secondToLastPageLink);
                    }
                    /** @type {?} */
                    const lastPageLink = this.makePage(totalPages, totalPages, false);
                    pages.push(lastPageLink);
                }
            }
        }
        return pages;
    }
    /**
     * Updates the pagination component
     * @return {?}
     */
    updatePages() {
        /** @type {?} */
        const instance = this._angularPaginatorService.getInstance(this.id);
        /** @type {?} */
        const correctedCurrentPage = this.outOfBoundCorrection(instance);
        if (correctedCurrentPage !== instance['currentPage'] || this.currentPage !== instance['currentPage']) {
            this.setCurrentPage(correctedCurrentPage);
        }
        this.pages = this.getPages(instance.currentPage, instance.itemsPerPage, instance.totalItems);
        return;
    }
    /**
     * Check if currentPage is out of bound with totalPages
     *
     * @param {?} instance instance for which the range is to be corrected
     * @return {?}
     */
    outOfBoundCorrection(instance) {
        /** @type {?} */
        const totalPages = Math.ceil(instance['totalItems'] / instance['itemsPerPage']);
        if (totalPages < instance['currentPage'] && 0 < totalPages) {
            return totalPages;
        }
        else if (instance['currentPage'] < 1) {
            return 1;
        }
        return instance['currentPage'];
    }
    /**
     * check if there is any instance registered with the id
     * @return {?}
     */
    isValidId() {
        if (!this._angularPaginatorService.getInstance(this.id)) {
            throw new Error('There is no instance registered with id `' + this.id + '`');
        }
        return;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isValidId();
        this.updatePages();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        /** destroy the subscription when the directive is destroyed */
        this.subscription.unsubscribe();
    }
}
AngularPaginatorDirective.decorators = [
    { type: Directive, args: [{
                selector: 'appAngularPaginator, [appAngularPaginator]',
                exportAs: 'angularPaginator'
            },] }
];
/** @nocollapse */
AngularPaginatorDirective.ctorParameters = () => [
    { type: AngularPaginatorService },
    { type: ChangeDetectorRef }
];
AngularPaginatorDirective.propDecorators = {
    boundaryLinks: [{ type: Input }],
    directionLinks: [{ type: Input }],
    maxSize: [{ type: Input }],
    rotate: [{ type: Input }],
    boundaryLinkNumbers: [{ type: Input }],
    forceEllipses: [{ type: Input }],
    id: [{ type: Input }],
    pageChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AngularPaginatorModule {
}
AngularPaginatorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                providers: [AngularPaginatorService],
                declarations: [AngularPaginatorComponent, AngularPaginatorPipe, AngularPaginatorDirective],
                exports: [AngularPaginatorComponent, AngularPaginatorPipe, AngularPaginatorDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { AngularPaginatorModule, AngularPaginatorComponent as ɵb, AngularPaginatorDirective as ɵd, AngularPaginatorPipe as ɵc, AngularPaginatorService as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1wYWdpbmF0b3IuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXItcGFnaW5hdG9yL2FwcC9hbmd1bGFyLXBhZ2luYXRvci9zZXJ2aWNlcy9hbmd1bGFyLXBhZ2luYXRvci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLXBhZ2luYXRvci9hcHAvYW5ndWxhci1wYWdpbmF0b3IvYW5ndWxhci1wYWdpbmF0b3IuY29tcG9uZW50LnRzIiwibmc6Ly9hbmd1bGFyLXBhZ2luYXRvci9hcHAvYW5ndWxhci1wYWdpbmF0b3IvcGlwZXMvYW5ndWxhci1wYWdpbmF0b3IucGlwZS50cyIsIm5nOi8vYW5ndWxhci1wYWdpbmF0b3IvYXBwL2FuZ3VsYXItcGFnaW5hdG9yL2RpcmVjdGl2ZXMvYW5ndWxhci1wYWdpbmF0b3IuZGlyZWN0aXZlLnRzIiwibmc6Ly9hbmd1bGFyLXBhZ2luYXRvci9hcHAvYW5ndWxhci1wYWdpbmF0b3IvYW5ndWxhci1wYWdpbmF0b3IubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5ndWxhclBhZ2luYXRvckluc3RhbmNlIH0gZnJvbSAnLi4vb3RoZXJzL2FuZ3VsYXItcGFnaW5hdG9yLmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbmd1bGFyUGFnaW5hdG9yU2VydmljZSB7XG4gIC8qKiBpZCBpcyB1c2VkIHRvIGlkZW50aWZ5IHBhZ2luYXRpb24gaW5zdGFuY2VzICovXG4gIGlkID0gJ0FOR1VMQVJfUEFHSU5BVE9SX0RFRkFVTFQnO1xuXG4gIC8qKiBpbnN0YW5jZXMgaXMgdGhlIGNvbGxlY3Rpb24gb2YgcGFnaW5hdGlvbiBjb21wb25ldG5zICovXG4gIGluc3RhbmNlczogYW55ID0ge307XG5cbiAgLyoqIGVtaXRzIGFuIGV2ZW50IHdpdGggaW5zdGFuY2UgaWQgd2hlbmV2ZXIgdGhlIHBhZ2UgbnVtYmVyIGNoYW5nZXMgKi9cbiAgY2hhbmdlOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gIGNvbnN0cnVjdG9yKCkgeyB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZXMgYW4gaW5zdGFuY2UgZm9yIGV2ZXJ5IHBpcGUgZGlmZmVyZW50aWF0ZWQgd2l0aCBpZFxuICAgKlxuICAgKiBAcGFyYW0gaW5zdGFuY2UgZWFjaCBpbnN0YW5jZSByZWZlcnMgdG8gYSB1bmlxdWUgcGFnaW5hdGlvbiBjb21wb25lbnRcbiAgICovXG4gIHJlZ2lzdGVySW5zdGFuY2UoaW5zdGFuY2U6IEFuZ3VsYXJQYWdpbmF0b3JJbnN0YW5jZSk6IHZvaWQge1xuXG4gICAgaWYgKCF0aGlzLmluc3RhbmNlc1tpbnN0YW5jZS5pZF0pIHtcbiAgICAgIHRoaXMuaW5zdGFuY2VzW2luc3RhbmNlLmlkXSA9IGluc3RhbmNlO1xuICAgICAgdGhpcy5jaGFuZ2UuZW1pdChpbnN0YW5jZS5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLnVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoaW5zdGFuY2UuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiB1cGRhdGVzIGV4aXN0aW5nIHBhZ2luYXRpb24gaW5zdGFuY2VzIGF2YWlsYWJsZVxuICAgKiBhbmQgcmV0dXJucyB0cnVlIGlmIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAqXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBhbiB1bmlxdWUgcGFnaW5hdGlvbiBjb21wb25lbnRcbiAgICovXG4gIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlOiBBbmd1bGFyUGFnaW5hdG9ySW5zdGFuY2UpOiBib29sZWFuIHtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlKSB7XG4gICAgICBpZiAoaW5zdGFuY2Vba2V5XSAhPT0gdGhpcy5pbnN0YW5jZXNbaW5zdGFuY2VbJ2lkJ11dW2tleV0pIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNbaW5zdGFuY2VbJ2lkJ11dW2tleV0gPSBpbnN0YW5jZVtrZXldO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIGluc3RhbmNlIHdpdGggZ2l2ZW4gaWRcbiAgICpcbiAgICogQHBhcmFtIGlkIHVuaXF1ZSBpZCBvZiB0aGUgcGFnaW5hdGlvbiBjb21wb25lbnRcbiAgICovXG4gIGdldEluc3RhbmNlKGlkOiBzdHJpbmcpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlc1tpZF07XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIGN1cnJlbnRQYWdlIGZvciBnaXZlbiBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgdW5pcXVlIGlkIG9mIHRoZSBwYWdpbmF0aW9uIGNvbXBvbmVudFxuICAgKi9cbiAgZ2V0Q3VycmVudFBhZ2UoaWQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzW2lkXS5jdXJyZW50UGFnZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9hbmd1bGFyLXBhZ2luYXRvci5zZXJ2aWNlJztcblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IHRoYXQgcmVuZGVycyB0aGUgUGFnaW5hdGlvbiBjb21wb25lbnQgdGVtcGxhdGUsIEl0IGFsc28gYWNjZXB0cyB0aGUgaW5wdXRzIGZvciB0aGUgUGFnaW5hdGlvbiBjb21wb25lbnRcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYXBwLWFuZ3VsYXItcGFnaW5hdG9yJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2FuZ3VsYXItcGFnaW5hdG9yLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vYW5ndWxhci1wYWdpbmF0b3IuY29tcG9uZW50LnNjc3MnXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5cbmV4cG9ydCBjbGFzcyBBbmd1bGFyUGFnaW5hdG9yQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAvKipcbiAgICogV2hldGhlciB0byBkaXNwbGF5IEZpcnN0IC8gTGFzdCBidXR0b25zXG4gICAqL1xuICBASW5wdXQoKSBib3VuZGFyeUxpbmtzID0gZmFsc2U7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRpc3BsYXkgUHJldmlvdXMgLyBOZXh0IGJ1dHRvbnNcbiAgICovXG4gIEBJbnB1dCgpIGRpcmVjdGlvbkxpbmtzID0gdHJ1ZTtcbiAgLyoqXG4gICAqIExpbWl0IG51bWJlciBmb3IgcGFnaW5hdGlvbiBzaXplLCBpLmUuLCB0aGUgbWF4aW11bSBwYWdlIG51bWJlcnMgdG8gYmUgZGlzcGxheWVkXG4gICAqL1xuICBASW5wdXQoKSBtYXhTaXplID0gNTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8ga2VlcCBjdXJyZW50IHBhZ2UgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXG4gICAqL1xuICBASW5wdXQoKSByb3RhdGUgPSB0cnVlO1xuICAvKipcbiAgICAqIFdoZXRoZXIgdG8gYWx3YXlzIGRpc3BsYXkgdGhlIGZpcnN0IGFuZCBsYXN0IHBhZ2UgbnVtYmVycy5cbiAgICAqIElmIG1heC1zaXplIGlzIHNtYWxsZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHBhZ2VzLCB0aGVuIHRoZSBmaXJzdCBhbmQgbGFzdCBwYWdlIG51bWJlcnMgYXJlIHN0aWxsIHNob3duIHdpdGggZWxsaXBzZXNcbiAgICAqIGluLWJldHdlZW4gYXMgbmVjZXNzYXJ5LiBOT1RFOiBtYXgtc2l6ZSByZWZlcnMgdG8gdGhlIGNlbnRlciBvZiB0aGUgcmFuZ2UuXG4gICAgKiBUaGlzIG9wdGlvbiBtYXkgYWRkIHVwIHRvIDIgbW9yZSBudW1iZXJzIG9uIGVhY2ggc2lkZSBvZiB0aGUgZGlzcGxheWVkIHJhbmdlIGZvciB0aGUgZW5kIHZhbHVlIGFuZFxuICAgICogd2hhdCB3b3VsZCBiZSBhbiBlbGxpcHNpcyBidXQgaXMgcmVwbGFjZWQgYnkgYSBudW1iZXIgYmVjYXVzZSBpdCBpcyBzZXF1ZW50aWFsXG4gICAgKi9cbiAgQElucHV0KCkgYm91bmRhcnlMaW5rTnVtYmVycyA9IGZhbHNlO1xuICAvKipcbiAgICogQWxzbyBkaXNwbGF5cyBlbGxpcHNlcyB3aGVuIHJvdGF0ZSBpcyB0cnVlIGFuZCBtYXhTaXplIGlzIHNtYWxsZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHBhZ2VzIGZvcmNlRWxsaXBzZXNcbiAgICovXG4gIEBJbnB1dCgpIGZvcmNlRWxsaXBzZXMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFVzZSB1bmlxdWUgaWQgd2hlbiBtdWx0aXBsZSBwYWdpbmF0aW9ucyBhcmUgYmVpbmcgdXNlZCBvbiB0aGUgc2FtZSBwYWdlLiBCeSBEZWZhdWx0IFBhZ2luYXRvciB1c2VzIGlkIGBBTkdVTEFSX1BBR0lOQVRPUl9ERUZBVUxUYFxuICAgKi9cbiAgQElucHV0KCkgaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRleHQgZm9yIGZpcnN0IGJ1dHRvblxuICAgKi9cbiAgQElucHV0KCkgZmlyc3RUZXh0ID0gJ0ZpcnN0JztcbiAgLyoqXG4gICAqIFRleHQgZm9yIHByZXZpb3VzIGJ1dHRvblxuICAgKi9cbiAgQElucHV0KCkgcHJldmlvdXNUZXh0ID0gJ1ByZXZpb3VzJztcbiAgLyoqXG4gICAqIFRleHQgZm9yIG5leHQgYnV0dG9uXG4gICAqL1xuICBASW5wdXQoKSBuZXh0VGV4dCA9ICdOZXh0JztcbiAgLyoqXG4gICAqIFRleHQgZm9yIGxhc3QgYnV0dG9uXG4gICAqL1xuICBASW5wdXQoKSBsYXN0VGV4dCA9ICdMYXN0JztcbiAgLyoqXG4gICAqIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgZmlyc3QgYnV0dG9uXG4gICAqL1xuICBASW5wdXQoKSBzY3JlZW5SZWFkZXJGaXJzdFRleHQgPSAnRmlyc3QnO1xuICAvKipcbiAgKiBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHByZXZpb3VzIGJ1dHRvblxuICAqL1xuICBASW5wdXQoKSBzY3JlZW5SZWFkZXJQcmV2aW91c1RleHQgPSAnUHJldmlvdXMnO1xuICAvKipcbiAgKiBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIG5leHQgYnV0dG9uXG4gICovXG4gIEBJbnB1dCgpIHNjcmVlblJlYWRlck5leHRUZXh0ID0gJ05leHQnO1xuICAvKipcbiAgKiBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGxhc3IgYnV0dG9uXG4gICovXG4gIEBJbnB1dCgpIHNjcmVlblJlYWRlckxhc3RUZXh0ID0gJ0xhc3QnO1xuICAvKipcbiAgKiBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHBhZ2UgbnVtYmVyc1xuICAqL1xuICBASW5wdXQoKSBzY3JlZW5SZWFkZXJQYWdlVGV4dCA9ICdQYWdlJztcbiAgLyoqXG4gICogU2NyZWVuIHJlYWRlciB0ZXh0IGZvciBjdXJyZW50IHBhZ2VcbiAgKi9cbiAgQElucHV0KCkgc2NyZWVuUmVhZGVyQ3VycmVudFBhZ2VUZXh0ID0gJ1lvdWByZSBvbiBwYWdlJztcbiAgLyoqXG4gICogU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgcGFnaW5hdGlvbiBjb21wb25lbnRcbiAgKi9cbiAgQElucHV0KCkgc2NyZWVuUmVhZGVyUGFnaW5hdGlvbkxhYmVsID0gJ1BhZ2luYXRpb24nO1xuICAvKipcbiAgKiBBZGRzIGN1c3RvbSBjbGFzcyB0byB0aGUgcGFnaW5hdGlvbiBlbGVtZW50XG4gICovXG4gIEBJbnB1dCgpIGNsYXNzTmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogSGlkZXMgdGhlIHBhZ2luYXRpb24gY29tcG9uZW50IGlmIHRoZSBpdGVtcyBhcmUgbGVzcyB0aGFuIGBpdGVtc1BlclBhZ2VgXG4gICAqL1xuICBASW5wdXQoKSBhdXRvSGlkZSA9IGZhbHNlO1xuICAvKipcbiAgICogZGlzYWJsZXMgcGFnaW5hdGlvbiBjb21wb25lbnRcbiAgICovXG4gIEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW5ldmVyIHRoZSBjdXJyZW50IHBhZ2UgaXMgY2hhbmdlZCwgSXQgZW1pdHMgdGhlIGN1cnJlbnQgcGFnZSBudW1iZXJcbiAgICpcbiAgICogVGhpcyBldmVudCBpcyBvcmlnaW5hbGx5IHBpY2tlZCB1cCBmcm9tIGBBbmd1bGFyUGFnaW5hdG9yRGlyZWN0aXZlYFxuICAgKi9cbiAgQE91dHB1dCgpIHBhZ2VDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBfYW5ndWxhclBhZ2luYXRvclNlcnZpY2Ugc2VydmljZSBmb3IgYW5ndWxhciBwYWdpbmF0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlOiBBbmd1bGFyUGFnaW5hdG9yU2VydmljZSkgeyB9XG5cbiAgbmdPbkluaXQoKSB7XG5cbiAgICAvLyBzZXQgZGVmYXVsdCBpZCBpZiBub3QgcHJvdmlkZWRcbiAgICB0aGlzLmlkID0gdGhpcy5pZCA/IHRoaXMuaWQgOiB0aGlzLl9hbmd1bGFyUGFnaW5hdG9yU2VydmljZS5pZDtcblxuICAgIC8vIHNldCBkZWZhdWx0IGNsYXNzIGlmIG5vdCBwcm92aWRlZFxuICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgPyB0aGlzLmNsYXNzTmFtZSA6IHRoaXMuX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlLmlkO1xuICB9XG59XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbmd1bGFyUGFnaW5hdG9yU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuZ3VsYXItcGFnaW5hdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQW5ndWxhclBhZ2luYXRvckluc3RhbmNlIH0gZnJvbSAnLi4vb3RoZXJzL2FuZ3VsYXItcGFnaW5hdG9yLmludGVyZmFjZSc7XG5cbi8qKlxuICogUGFnaW5hdGlvbiBQaXBlIHdoaWNoIHBhZ2luYXRlcyB0aGUgYXJyYXkgZm9yIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgc3VjaCBhcyBgaXRlbXNQZXJQYWdlYCBhbmQgYGN1cnJlbnRQYWdlYFxuICovXG5AUGlwZSh7XG4gIG5hbWU6ICdhbmd1bGFyUGFnaW5hdG9yJ1xufSlcblxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJQYWdpbmF0b3JQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlIHNlcnZpY2UgZm9yIGFuZ3VsYXIgcGFnaWFudG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9hbmd1bGFyUGFnaW5hdG9yU2VydmljZTogQW5ndWxhclBhZ2luYXRvclNlcnZpY2UpIHsgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHBpcGVzIHBhZ2luYXRlcyB0aGUgYXJyYXkgZm9yIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgc3VjaCBhcyBgaXRlbXNQZXJQYWdlYCBhbmQgYGN1cnJlbnRQYWdlYFxuICAgKlxuICAgKiBAcGFyYW0gYXJyYXkgaW5wdXQgYXJyYXkgZm9yIHdoaWNoIHRoZSBtYW5pcHVsYXRpb24gaGFwcGVuc1xuICAgKiBAcGFyYW0gYXJncyBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBwYWdpbmF0b3IgcGlwZVxuICAgKi9cbiAgdHJhbnNmb3JtKGFycmF5OiBhbnksIGFyZ3M/OiBhbnkpOiBhbnkge1xuXG4gICAgY29uc3QgaW5zdGFuY2U6IEFuZ3VsYXJQYWdpbmF0b3JJbnN0YW5jZSA9IHRoaXMuY3JlYXRlSW5zdGFuY2UoYXJyYXksIGFyZ3MpO1xuXG4gICAgLy8gY3JlYXRlIHBhZ2luYXRpb24gaW5mb3JtYXRpb25cbiAgICB0aGlzLl9hbmd1bGFyUGFnaW5hdG9yU2VydmljZS5yZWdpc3Rlckluc3RhbmNlKGluc3RhbmNlKTtcblxuICAgIC8vIHNldCB0aGUgc2xpY2luZyByYW5nZVxuICAgIGNvbnN0IHN0YXJ0ID0gKGluc3RhbmNlLmN1cnJlbnRQYWdlIC0gMSkgKiBpbnN0YW5jZS5pdGVtc1BlclBhZ2U7XG4gICAgY29uc3QgZW5kID0gaW5zdGFuY2UuY3VycmVudFBhZ2UgKiBpbnN0YW5jZS5pdGVtc1BlclBhZ2U7XG5cbiAgICByZXR1cm4gYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGUgYW4gaW5zdGFuY2UgZm9yIGVhY2ggcGlwZVxuICAgKlxuICAgKiBAcGFyYW0gYXJyYXkgaW5wdXQgYXJyYXkgZm9yIHdoaWNoIHRoZSBtYW5pcHVsYXRpb24gaGFwcGVuc1xuICAgKiBAcGFyYW0gYXJncyBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBwYWdpbmF0b3IgcGlwZVxuICAgKi9cbiAgY3JlYXRlSW5zdGFuY2UoYXJyYXk6IGFueSwgYXJnczogYW55KTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGFyZ3NbJ2lkJ10gPyBhcmdzLmlkIDogdGhpcy5fYW5ndWxhclBhZ2luYXRvclNlcnZpY2UuaWQsXG4gICAgICBjdXJyZW50UGFnZTogYXJnc1snY3VycmVudFBhZ2UnXSA/IGFyZ3NbJ2N1cnJlbnRQYWdlJ10gOiAxLFxuICAgICAgaXRlbXNQZXJQYWdlOiBhcmdzWydpdGVtc1BlclBhZ2UnXSA/IGFyZ3NbJ2l0ZW1zUGVyUGFnZSddIDogMTAsXG4gICAgICB0b3RhbEl0ZW1zOiBhcnJheVsnbGVuZ3RoJ11cbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIE9uSW5pdCwgT25EZXN0cm95LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENoYW5nZURldGVjdG9yUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbmd1bGFyUGFnaW5hdG9yU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuZ3VsYXItcGFnaW5hdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQW5ndWxhclBhZ2luYXRvckluc3RhbmNlLCBQYWdlIH0gZnJvbSAnLi4vb3RoZXJzL2FuZ3VsYXItcGFnaW5hdG9yLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZGlyZWN0aXZlIHdoZXJlIHRoZSBhY3R1YWwgcGFnaW5hdGlvbiB0YWtlcyBwbGFjZSwgaXQgcHJvdmlkZXMgYSBzeW5jIGJldHdlZW4gdGhlXG4gKiBwaXBlcyBhbmQgdGhlIHBhZ2luYXRpb24gY29tcG9uZW50XG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2FwcEFuZ3VsYXJQYWdpbmF0b3IsIFthcHBBbmd1bGFyUGFnaW5hdG9yXScsXG4gIGV4cG9ydEFzOiAnYW5ndWxhclBhZ2luYXRvcidcbn0pXG5cbmV4cG9ydCBjbGFzcyBBbmd1bGFyUGFnaW5hdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRpc3BsYXkgRmlyc3QgLyBMYXN0IGJ1dHRvbnNcbiAgICovXG4gIEBJbnB1dCgpIGJvdW5kYXJ5TGlua3M6IGJvb2xlYW47XG4gIC8qKlxuICAqIFdoZXRoZXIgdG8gZGlzcGxheSBQcmV2aW91cyAvIE5leHQgYnV0dG9uc1xuICAqL1xuICBASW5wdXQoKSBkaXJlY3Rpb25MaW5rczogYm9vbGVhbjtcbiAgLyoqXG4gICAqIExpbWl0IG51bWJlciBmb3IgcGFnaW5hdGlvbiBzaXplLCBpLmUuLCB0aGUgbWF4aW11bSBwYWdlIG51bWJlcnMgdG8gYmUgZGlzcGxheWVkXG4gICAqL1xuICBASW5wdXQoKSBtYXhTaXplOiBudW1iZXI7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGtlZXAgY3VycmVudCBwYWdlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xuICAgKi9cbiAgQElucHV0KCkgcm90YXRlOiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0byBhbHdheXMgZGlzcGxheSB0aGUgZmlyc3QgYW5kIGxhc3QgcGFnZSBudW1iZXJzLlxuICAgKiBJZiBtYXgtc2l6ZSBpcyBzbWFsbGVyIHRoYW4gdGhlIG51bWJlciBvZiBwYWdlcywgdGhlbiB0aGUgZmlyc3QgYW5kIGxhc3QgcGFnZSBudW1iZXJzIGFyZSBzdGlsbCBzaG93biB3aXRoIGVsbGlwc2VzXG4gICAqIGluLWJldHdlZW4gYXMgbmVjZXNzYXJ5LiBOT1RFOiBtYXgtc2l6ZSByZWZlcnMgdG8gdGhlIGNlbnRlciBvZiB0aGUgcmFuZ2UuXG4gICAqIFRoaXMgb3B0aW9uIG1heSBhZGQgdXAgdG8gMiBtb3JlIG51bWJlcnMgb24gZWFjaCBzaWRlIG9mIHRoZSBkaXNwbGF5ZWQgcmFuZ2UgZm9yIHRoZSBlbmQgdmFsdWUgYW5kXG4gICAqIHdoYXQgd291bGQgYmUgYW4gZWxsaXBzaXMgYnV0IGlzIHJlcGxhY2VkIGJ5IGEgbnVtYmVyIGJlY2F1c2UgaXQgaXMgc2VxdWVudGlhbFxuICAgKi9cbiAgQElucHV0KCkgYm91bmRhcnlMaW5rTnVtYmVyczogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFsc28gZGlzcGxheXMgZWxsaXBzZXMgd2hlbiByb3RhdGUgaXMgdHJ1ZSBhbmQgbWF4U2l6ZSBpcyBzbWFsbGVyIHRoYW4gdGhlIG51bWJlciBvZiBwYWdlcyBmb3JjZUVsbGlwc2VzXG4gICAqL1xuICBASW5wdXQoKSBmb3JjZUVsbGlwc2VzOiBib29sZWFuO1xuICAvKipcbiAgICogVXNlIHVuaXF1ZSBpZCB3aGVuIG11bHRpcGxlIHBhZ2luYXRpb25zIGFyZSBiZWluZyB1c2VkIG9uIHRoZSBzYW1lIHBhZ2UuIEJ5IERlZmF1bHQgUGFnaW5hdG9yIHVzZXMgaWQgYEFOR1VMQVJfUEFHSU5BVE9SX0RFRkFVTFRgXG4gICAqL1xuICBASW5wdXQoKSBpZDogc3RyaW5nO1xuXG4gIGN1cnJlbnRQYWdlOiBudW1iZXI7XG4gIGZpcnN0UGFnZSA9IDE7XG4gIGxhc3RQYWdlOiBudW1iZXI7XG4gIHBhZ2VzOiBQYWdlW10gPSBbXTtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgcGFnZSBpcyBjaGFuZ2VkLCBJdCBlbWl0cyB0aGUgY3VycmVudCBwYWdlIG51bWJlclxuICAgKi9cbiAgQE91dHB1dCgpIHBhZ2VDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KHRydWUpO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlIHNlcml2Y2UgZm9yIGFuZ3VsYXIgcGFnaW5hdG9yXG4gICAqIEBwYXJhbSBfY2hhbmdlRGV0ZWN0b3JSZWYgZm9yIG1hbnVhbCBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9hbmd1bGFyUGFnaW5hdG9yU2VydmljZTogQW5ndWxhclBhZ2luYXRvclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5fYW5ndWxhclBhZ2luYXRvclNlcnZpY2UuY2hhbmdlLnN1YnNjcmliZShpZCA9PiB7XG4gICAgICBpZiAoaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYWdlcygpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHByZXZvaXVzIHBhZ2VcbiAgICovXG4gIHRvUHJldmlvdXNQYWdlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlID4gdGhpcy5maXJzdFBhZ2UpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UodGhpcy5jdXJyZW50UGFnZSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gbmV4dCBwYWdlXG4gICAqL1xuICB0b05leHRQYWdlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlIDwgdGhpcy5sYXN0UGFnZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UGFnZSh0aGlzLmN1cnJlbnRQYWdlICsgMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byBmaXJzdCBwYWdlXG4gICAqL1xuICB0b0ZpcnN0UGFnZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNldEN1cnJlbnRQYWdlKHRoaXMuZmlyc3RQYWdlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gbGFzdCBwYWdlXG4gICAqL1xuICB0b0xhc3RQYWdlKCk6IHZvaWQge1xuICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UodGhpcy5sYXN0UGFnZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgY3VycmVudCBwYWdlXG4gICAqXG4gICAqIEBwYXJhbSBwYWdlIHBhZ2UgbnVtYmVyIHRvIHNldCBhcyBjdXJyZW50UGFnZVxuICAgKi9cbiAgc2V0Q3VycmVudFBhZ2UocGFnZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHBhZ2UgJiYgdGhpcy5jdXJyZW50UGFnZSAhPT0gcGFnZSkge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdChwYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBwYWdlIG9iamVjdCB1c2VkIGZvciB0ZW1wbGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gbnVtYmVyIHBhZ2UgbnVtYmVyXG4gICAqIEBwYXJhbSB0ZXh0IHBhZ2UgbnVtYmVyLCB0ZXh0IHRvIGJlIGRpc3BsYXllZFxuICAgKiBAcGFyYW0gaXNBY3RpdmUgd2hldGhlciB0aGUgcGFnZSBpcyBhY3RpdmUgb3Igbm90LCB0cnVlIGZvciBjdXJyZW50UGFnZVxuICAgKi9cbiAgbWFrZVBhZ2UobnVtYmVyOiBudW1iZXIsIHRleHQ6IGFueSwgaXNBY3RpdmU6IGJvb2xlYW4pOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBhY3RpdmU6IGlzQWN0aXZlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgY3JlYXRlIHBhZ2UgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIGN1cnJlbnRQYWdlIGN1cnJlbnQgcGFnZSBudW1iZXJcbiAgICogQHBhcmFtIGl0ZW1zUGVyUGFnZSB0b3RhbCBpdGVtcyBwZXIgcGFnZVxuICAgKiBAcGFyYW0gdG90YWxJdGVtcyBubyBvZiBpdGVtcyBmb3IgcGFnaW5hdGlvbiwgdXN1YWxseSBhcnJheSBsZW5ndGhcbiAgICovXG4gIGdldFBhZ2VzKGN1cnJlbnRQYWdlOiBudW1iZXIsIGl0ZW1zUGVyUGFnZTogbnVtYmVyLCB0b3RhbEl0ZW1zOiBudW1iZXIpOiBhbnkge1xuICAgIGNvbnN0IHBhZ2VzOiBhbnkgPSBbXTtcblxuICAgIC8vIERlZmF1bHQgcGFnZSBsaW1pdHNcbiAgICBjb25zdCB0b3RhbFBhZ2VzOiBudW1iZXIgPSB0aGlzLmxhc3RQYWdlID0gTWF0aC5jZWlsKHRvdGFsSXRlbXMgLyBpdGVtc1BlclBhZ2UpO1xuXG4gICAgbGV0IHN0YXJ0UGFnZSA9IDE7XG4gICAgbGV0IGVuZFBhZ2U6IG51bWJlciA9IHRvdGFsUGFnZXM7XG4gICAgY29uc3QgaXNNYXhTaXplZDogYm9vbGVhbiA9IHRoaXMubWF4U2l6ZSAmJiB0aGlzLm1heFNpemUgPCB0b3RhbFBhZ2VzO1xuXG4gICAgLy8gcmVjb21wdXRlIGlmIG1heFNpemVcbiAgICBpZiAoaXNNYXhTaXplZCkge1xuXG4gICAgICBpZiAodGhpcy5yb3RhdGUpIHtcblxuICAgICAgICAvLyBjdXJyZW50IHBhZ2UgaXMgZGlzcGxheWVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xuICAgICAgICBzdGFydFBhZ2UgPSBNYXRoLm1heChjdXJyZW50UGFnZSAtIE1hdGguZmxvb3IodGhpcy5tYXhTaXplIC8gMiksIDEpO1xuICAgICAgICBlbmRQYWdlID0gc3RhcnRQYWdlICsgdGhpcy5tYXhTaXplIC0gMTtcblxuICAgICAgICAvLyBBZGp1c3QgaWYgbGltaXQgaXMgZXhjZWVkZWRcbiAgICAgICAgaWYgKGVuZFBhZ2UgPiB0b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgICAgICAgc3RhcnRQYWdlID0gZW5kUGFnZSAtIHRoaXMubWF4U2l6ZSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFZpc2libGUgcGFnZXMgYXJlIHBhZ2luYXRlZCB3aXRoIG1heFNpemVcbiAgICAgICAgc3RhcnRQYWdlID0gKE1hdGguY2VpbChjdXJyZW50UGFnZSAvIHRoaXMubWF4U2l6ZSkgLSAxKSAqIHRoaXMubWF4U2l6ZSArIDE7XG5cbiAgICAgICAgLy8gYWRqdXN0IGxhc3QgcGFnZSBpZiBsaW1pdCBpcyBleGNlZWRlZFxuICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oc3RhcnRQYWdlICsgdGhpcy5tYXhTaXplIC0gMSwgdG90YWxQYWdlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHBhZ2UgbnVtYmVyIGxpbmtzXG4gICAgZm9yIChsZXQgbnVtYmVyID0gc3RhcnRQYWdlOyBudW1iZXIgPD0gZW5kUGFnZTsgbnVtYmVyKyspIHtcbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLm1ha2VQYWdlKG51bWJlciwgbnVtYmVyLCBudW1iZXIgPT09IGN1cnJlbnRQYWdlKTtcbiAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGxpbmtzIHRvIG1vdmUgYmV0d2VlbiBwYWdlIHNldHNcbiAgICBpZiAoaXNNYXhTaXplZCAmJiB0aGlzLm1heFNpemUgPiAwICYmICghdGhpcy5yb3RhdGUgfHwgdGhpcy5mb3JjZUVsbGlwc2VzIHx8IHRoaXMuYm91bmRhcnlMaW5rTnVtYmVycykpIHtcbiAgICAgIGlmIChzdGFydFBhZ2UgPiAxKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJvdW5kYXJ5TGlua051bWJlcnMgfHwgc3RhcnRQYWdlID4gMykgeyAvLyBuZWVkIGVsbGlwc2lzIGZvciBhbGwgb3B0aW9ucyB1bmxlc3MgcmFuZ2UgaXMgdG9vIGNsb3NlIHRvIGJlZ2lubmluZ1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGFnZVNldCA9IHRoaXMubWFrZVBhZ2Uoc3RhcnRQYWdlIC0gMSwgJy4uLicsIGZhbHNlKTtcbiAgICAgICAgICBwYWdlcy51bnNoaWZ0KHByZXZpb3VzUGFnZVNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ib3VuZGFyeUxpbmtOdW1iZXJzKSB7XG5cbiAgICAgICAgICBpZiAoc3RhcnRQYWdlID09PSAzKSB7IC8vIG5lZWQgdG8gcmVwbGFjZSBlbGxpcHNpcyB3aGVuIHRoZSBidXR0b25zIHdvdWxkIGJlIHNlcXVlbnRpYWxcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFBhZ2VMaW5rID0gdGhpcy5tYWtlUGFnZSgyLCAnMicsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoc2Vjb25kUGFnZUxpbmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgIGNvbnN0IGZpcnN0UGFnZUxpbmsgPSB0aGlzLm1ha2VQYWdlKDEsICcxJywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoZmlyc3RQYWdlTGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFBhZ2UgPCB0b3RhbFBhZ2VzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJvdW5kYXJ5TGlua051bWJlcnMgfHwgZW5kUGFnZSA8IHRvdGFsUGFnZXMgLSAyKSB7IC8vIG5lZWQgZWxsaXBzaXMgZm9yIGFsbCBvcHRpb25zIHVubGVzcyByYW5nZSBpcyB0b28gY2xvc2UgdG8gZW5kXG4gICAgICAgICAgY29uc3QgbmV4dFBhZ2VTZXQgPSB0aGlzLm1ha2VQYWdlKGVuZFBhZ2UgKyAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnB1c2gobmV4dFBhZ2VTZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYm91bmRhcnlMaW5rTnVtYmVycykge1xuXG4gICAgICAgICAgaWYgKGVuZFBhZ2UgPT09IHRvdGFsUGFnZXMgLSAyKSB7IC8vIG5lZWQgdG8gcmVwbGFjZSBlbGxpcHNpcyB3aGVuIHRoZSBidXR0b25zIHdvdWxkIGJlIHNlcXVlbnRpYWxcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFRvTGFzdFBhZ2VMaW5rID0gdGhpcy5tYWtlUGFnZSh0b3RhbFBhZ2VzIC0gMSwgdG90YWxQYWdlcyAtIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhZ2VzLnB1c2goc2Vjb25kVG9MYXN0UGFnZUxpbmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCB0aGUgbGFzdCBwYWdlXG4gICAgICAgICAgY29uc3QgbGFzdFBhZ2VMaW5rID0gdGhpcy5tYWtlUGFnZSh0b3RhbFBhZ2VzLCB0b3RhbFBhZ2VzLCBmYWxzZSk7XG4gICAgICAgICAgcGFnZXMucHVzaChsYXN0UGFnZUxpbmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwYWdpbmF0aW9uIGNvbXBvbmVudFxuICAgKi9cbiAgdXBkYXRlUGFnZXMoKTogdm9pZCB7XG4gICAgY29uc3QgaW5zdGFuY2U6IEFuZ3VsYXJQYWdpbmF0b3JJbnN0YW5jZSA9IHRoaXMuX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuaWQpO1xuXG4gICAgY29uc3QgY29ycmVjdGVkQ3VycmVudFBhZ2UgPSB0aGlzLm91dE9mQm91bmRDb3JyZWN0aW9uKGluc3RhbmNlKTtcblxuICAgIGlmIChjb3JyZWN0ZWRDdXJyZW50UGFnZSAhPT0gaW5zdGFuY2VbJ2N1cnJlbnRQYWdlJ10gfHwgdGhpcy5jdXJyZW50UGFnZSAhPT0gaW5zdGFuY2VbJ2N1cnJlbnRQYWdlJ10pIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UoY29ycmVjdGVkQ3VycmVudFBhZ2UpO1xuICAgIH1cblxuICAgIHRoaXMucGFnZXMgPSB0aGlzLmdldFBhZ2VzKGluc3RhbmNlLmN1cnJlbnRQYWdlLCBpbnN0YW5jZS5pdGVtc1BlclBhZ2UsIGluc3RhbmNlLnRvdGFsSXRlbXMpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGN1cnJlbnRQYWdlIGlzIG91dCBvZiBib3VuZCB3aXRoIHRvdGFsUGFnZXNcbiAgICpcbiAgICogQHBhcmFtIGluc3RhbmNlIGluc3RhbmNlIGZvciB3aGljaCB0aGUgcmFuZ2UgaXMgdG8gYmUgY29ycmVjdGVkXG4gICAqL1xuICBvdXRPZkJvdW5kQ29ycmVjdGlvbihpbnN0YW5jZTogQW5ndWxhclBhZ2luYXRvckluc3RhbmNlKTogbnVtYmVyIHtcblxuICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLmNlaWwoaW5zdGFuY2VbJ3RvdGFsSXRlbXMnXSAvIGluc3RhbmNlWydpdGVtc1BlclBhZ2UnXSk7XG5cbiAgICBpZiAodG90YWxQYWdlcyA8IGluc3RhbmNlWydjdXJyZW50UGFnZSddICYmIDAgPCB0b3RhbFBhZ2VzKSB7XG4gICAgICByZXR1cm4gdG90YWxQYWdlcztcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlWydjdXJyZW50UGFnZSddIDwgMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlWydjdXJyZW50UGFnZSddO1xuICB9XG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIHRoZXJlIGlzIGFueSBpbnN0YW5jZSByZWdpc3RlcmVkIHdpdGggdGhlIGlkXG4gICAqL1xuICBpc1ZhbGlkSWQoKTogdm9pZCB7XG5cbiAgICBpZiAoIXRoaXMuX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGluc3RhbmNlIHJlZ2lzdGVyZWQgd2l0aCBpZCBgJyArIHRoaXMuaWQgKyAnYCcpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuaXNWYWxpZElkKCk7XG4gICAgdGhpcy51cGRhdGVQYWdlcygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgLyoqIGRlc3Ryb3kgdGhlIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBkaXJlY3RpdmUgaXMgZGVzdHJveWVkICovXG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFuZ3VsYXJQYWdpbmF0b3JDb21wb25lbnQgfSBmcm9tICcuL2FuZ3VsYXItcGFnaW5hdG9yLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBbmd1bGFyUGFnaW5hdG9yUGlwZSB9IGZyb20gJy4vcGlwZXMvYW5ndWxhci1wYWdpbmF0b3IucGlwZSc7XG5pbXBvcnQgeyBBbmd1bGFyUGFnaW5hdG9yRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL2FuZ3VsYXItcGFnaW5hdG9yLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBBbmd1bGFyUGFnaW5hdG9yU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvYW5ndWxhci1wYWdpbmF0b3Iuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGVcbiAgXSxcbiAgcHJvdmlkZXJzOiBbQW5ndWxhclBhZ2luYXRvclNlcnZpY2VdLFxuICBkZWNsYXJhdGlvbnM6IFtBbmd1bGFyUGFnaW5hdG9yQ29tcG9uZW50LCBBbmd1bGFyUGFnaW5hdG9yUGlwZSwgQW5ndWxhclBhZ2luYXRvckRpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtBbmd1bGFyUGFnaW5hdG9yQ29tcG9uZW50LCBBbmd1bGFyUGFnaW5hdG9yUGlwZSwgQW5ndWxhclBhZ2luYXRvckRpcmVjdGl2ZV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBBbmd1bGFyUGFnaW5hdG9yTW9kdWxlIHsgfVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7SUFjRTs7OztrQkFSSywyQkFBMkI7Ozs7eUJBR2YsRUFBRTs7OztzQkFHWSxJQUFJLFlBQVksRUFBVTtLQUV4Qzs7Ozs7OztJQU9qQixnQkFBZ0IsQ0FBQyxRQUFrQztRQUVqRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDaEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDO1lBQ3ZDLElBQUksQ0FB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