/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Directive, Input, Output, EventEmitter, ChangeDetectorRef } from '@angular/core';
import { AngularPaginatorService } from '../services/angular-paginator.service';
import { Subject } from 'rxjs';
/**
 * This is the directive where the actual pagination takes place, it provides a sync between the
 * pipes and the pagination component
 */
var AngularPaginatorDirective = /** @class */ (function () {
    /**
     *
     * @param _angularPaginatorService serivce for angular paginator
     * @param _changeDetectorRef for manual change detection
     */
    function AngularPaginatorDirective(_angularPaginatorService, _changeDetectorRef) {
        var _this = this;
        this._angularPaginatorService = _angularPaginatorService;
        this._changeDetectorRef = _changeDetectorRef;
        this.firstPage = 1;
        this.pages = [];
        this.subscription = new Subject();
        /**
         * Emits an event whenever the current page is changed, It emits the current page number
         */
        this.pageChange = new EventEmitter(true);
        // subscribe to changes
        this.subscription = this._angularPaginatorService.change.subscribe(function (id) {
            if (id === _this.id) {
                _this.updatePages();
                _this._changeDetectorRef.markForCheck();
            }
        });
    }
    /**
     * Navigate to prevoius page
     */
    /**
     * Navigate to prevoius page
     * @return {?}
     */
    AngularPaginatorDirective.prototype.toPreviousPage = /**
     * Navigate to prevoius page
     * @return {?}
     */
    function () {
        if (this.currentPage > this.firstPage) {
            this.setCurrentPage(this.currentPage - 1);
        }
        return;
    };
    /**
     * Navigate to next page
     */
    /**
     * Navigate to next page
     * @return {?}
     */
    AngularPaginatorDirective.prototype.toNextPage = /**
     * Navigate to next page
     * @return {?}
     */
    function () {
        if (this.currentPage < this.lastPage) {
            this.setCurrentPage(this.currentPage + 1);
        }
        return;
    };
    /**
     * Navigate to first page
     */
    /**
     * Navigate to first page
     * @return {?}
     */
    AngularPaginatorDirective.prototype.toFirstPage = /**
     * Navigate to first page
     * @return {?}
     */
    function () {
        this.setCurrentPage(this.firstPage);
        return;
    };
    /**
     * Navigate to last page
     */
    /**
     * Navigate to last page
     * @return {?}
     */
    AngularPaginatorDirective.prototype.toLastPage = /**
     * Navigate to last page
     * @return {?}
     */
    function () {
        this.setCurrentPage(this.lastPage);
        return;
    };
    /**
     * Sets current page
     *
     * @param page page number to set as currentPage
     */
    /**
     * Sets current page
     *
     * @param {?} page page number to set as currentPage
     * @return {?}
     */
    AngularPaginatorDirective.prototype.setCurrentPage = /**
     * Sets current page
     *
     * @param {?} page page number to set as currentPage
     * @return {?}
     */
    function (page) {
        if (page && this.currentPage !== page) {
            this.currentPage = page;
            this.pageChange.emit(page);
        }
        return;
    };
    /**
     * create page object used for template
     *
     * @param number page number
     * @param text page number, text to be displayed
     * @param isActive whether the page is active or not, true for currentPage
     */
    /**
     * create page object used for template
     *
     * @param {?} number page number
     * @param {?} text page number, text to be displayed
     * @param {?} isActive whether the page is active or not, true for currentPage
     * @return {?}
     */
    AngularPaginatorDirective.prototype.makePage = /**
     * create page object used for template
     *
     * @param {?} number page number
     * @param {?} text page number, text to be displayed
     * @param {?} isActive whether the page is active or not, true for currentPage
     * @return {?}
     */
    function (number, text, isActive) {
        return {
            number: number,
            text: text,
            active: isActive
        };
    };
    /**
     *  create page array
     *
     * @param currentPage current page number
     * @param itemsPerPage total items per page
     * @param totalItems no of items for pagination, usually array length
     */
    /**
     *  create page array
     *
     * @param {?} currentPage current page number
     * @param {?} itemsPerPage total items per page
     * @param {?} totalItems no of items for pagination, usually array length
     * @return {?}
     */
    AngularPaginatorDirective.prototype.getPages = /**
     *  create page array
     *
     * @param {?} currentPage current page number
     * @param {?} itemsPerPage total items per page
     * @param {?} totalItems no of items for pagination, usually array length
     * @return {?}
     */
    function (currentPage, itemsPerPage, totalItems) {
        /** @type {?} */
        var pages = [];
        /** @type {?} */
        var totalPages = this.lastPage = Math.ceil(totalItems / itemsPerPage);
        /** @type {?} */
        var startPage = 1;
        /** @type {?} */
        var endPage = totalPages;
        /** @type {?} */
        var isMaxSized = this.maxSize && this.maxSize < totalPages;
        // recompute if maxSize
        if (isMaxSized) {
            if (this.rotate) {
                // current page is displayed in the middle of the visible ones
                startPage = Math.max(currentPage - Math.floor(this.maxSize / 2), 1);
                endPage = startPage + this.maxSize - 1;
                // Adjust if limit is exceeded
                if (endPage > totalPages) {
                    endPage = totalPages;
                    startPage = endPage - this.maxSize + 1;
                }
            }
            else {
                // Visible pages are paginated with maxSize
                startPage = (Math.ceil(currentPage / this.maxSize) - 1) * this.maxSize + 1;
                // adjust last page if limit is exceeded
                endPage = Math.min(startPage + this.maxSize - 1, totalPages);
            }
        }
        // add page number links
        for (var number = startPage; number <= endPage; number++) {
            /** @type {?} */
            var page = this.makePage(number, number, number === currentPage);
            pages.push(page);
        }
        // add links to move between page sets
        if (isMaxSized && this.maxSize > 0 && (!this.rotate || this.forceEllipses || this.boundaryLinkNumbers)) {
            if (startPage > 1) {
                if (!this.boundaryLinkNumbers || startPage > 3) { // need ellipsis for all options unless range is too close to beginning
                    /** @type {?} */
                    var previousPageSet = this.makePage(startPage - 1, '...', false);
                    pages.unshift(previousPageSet);
                }
                if (this.boundaryLinkNumbers) {
                    if (startPage === 3) { // need to replace ellipsis when the buttons would be sequential
                        /** @type {?} */
                        var secondPageLink = this.makePage(2, '2', false);
                        pages.unshift(secondPageLink);
                    }
                    /** @type {?} */
                    var firstPageLink = this.makePage(1, '1', false);
                    pages.unshift(firstPageLink);
                }
            }
            if (endPage < totalPages) {
                if (!this.boundaryLinkNumbers || endPage < totalPages - 2) { // need ellipsis for all options unless range is too close to end
                    /** @type {?} */
                    var nextPageSet = this.makePage(endPage + 1, '...', false);
                    pages.push(nextPageSet);
                }
                if (this.boundaryLinkNumbers) {
                    if (endPage === totalPages - 2) { // need to replace ellipsis when the buttons would be sequential
                        /** @type {?} */
                        var secondToLastPageLink = this.makePage(totalPages - 1, totalPages - 1, false);
                        pages.push(secondToLastPageLink);
                    }
                    /** @type {?} */
                    var lastPageLink = this.makePage(totalPages, totalPages, false);
                    pages.push(lastPageLink);
                }
            }
        }
        return pages;
    };
    /**
     * Updates the pagination component
     */
    /**
     * Updates the pagination component
     * @return {?}
     */
    AngularPaginatorDirective.prototype.updatePages = /**
     * Updates the pagination component
     * @return {?}
     */
    function () {
        /** @type {?} */
        var instance = this._angularPaginatorService.getInstance(this.id);
        /** @type {?} */
        var correctedCurrentPage = this.outOfBoundCorrection(instance);
        if (correctedCurrentPage !== instance['currentPage'] || this.currentPage !== instance['currentPage']) {
            this.setCurrentPage(correctedCurrentPage);
        }
        this.pages = this.getPages(instance.currentPage, instance.itemsPerPage, instance.totalItems);
        return;
    };
    /**
     * Check if currentPage is out of bound with totalPages
     *
     * @param instance instance for which the range is to be corrected
     */
    /**
     * Check if currentPage is out of bound with totalPages
     *
     * @param {?} instance instance for which the range is to be corrected
     * @return {?}
     */
    AngularPaginatorDirective.prototype.outOfBoundCorrection = /**
     * Check if currentPage is out of bound with totalPages
     *
     * @param {?} instance instance for which the range is to be corrected
     * @return {?}
     */
    function (instance) {
        /** @type {?} */
        var totalPages = Math.ceil(instance['totalItems'] / instance['itemsPerPage']);
        if (totalPages < instance['currentPage'] && 0 < totalPages) {
            return totalPages;
        }
        else if (instance['currentPage'] < 1) {
            return 1;
        }
        return instance['currentPage'];
    };
    /**
     * check if there is any instance registered with the id
     */
    /**
     * check if there is any instance registered with the id
     * @return {?}
     */
    AngularPaginatorDirective.prototype.isValidId = /**
     * check if there is any instance registered with the id
     * @return {?}
     */
    function () {
        if (!this._angularPaginatorService.getInstance(this.id)) {
            throw new Error('There is no instance registered with id `' + this.id + '`');
        }
        return;
    };
    /**
     * @return {?}
     */
    AngularPaginatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.isValidId();
        this.updatePages();
    };
    /**
     * @return {?}
     */
    AngularPaginatorDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        /** destroy the subscription when the directive is destroyed */
        this.subscription.unsubscribe();
    };
    AngularPaginatorDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'appAngularPaginator, [appAngularPaginator]',
                    exportAs: 'angularPaginator'
                },] }
    ];
    /** @nocollapse */
    AngularPaginatorDirective.ctorParameters = function () { return [
        { type: AngularPaginatorService },
        { type: ChangeDetectorRef }
    ]; };
    AngularPaginatorDirective.propDecorators = {
        boundaryLinks: [{ type: Input }],
        directionLinks: [{ type: Input }],
        maxSize: [{ type: Input }],
        rotate: [{ type: Input }],
        boundaryLinkNumbers: [{ type: Input }],
        forceEllipses: [{ type: Input }],
        id: [{ type: Input }],
        pageChange: [{ type: Output }]
    };
    return AngularPaginatorDirective;
}());
export { AngularPaginatorDirective };
if (false) {
    /**
     * Whether to display First / Last buttons
     * @type {?}
     */
    AngularPaginatorDirective.prototype.boundaryLinks;
    /**
     * Whether to display Previous / Next buttons
     * @type {?}
     */
    AngularPaginatorDirective.prototype.directionLinks;
    /**
     * Limit number for pagination size, i.e., the maximum page numbers to be displayed
     * @type {?}
     */
    AngularPaginatorDirective.prototype.maxSize;
    /**
     * Whether to keep current page in the middle of the visible ones
     * @type {?}
     */
    AngularPaginatorDirective.prototype.rotate;
    /**
     * Whether to always display the first and last page numbers.
     * If max-size is smaller than the number of pages, then the first and last page numbers are still shown with ellipses
     * in-between as necessary. NOTE: max-size refers to the center of the range.
     * This option may add up to 2 more numbers on each side of the displayed range for the end value and
     * what would be an ellipsis but is replaced by a number because it is sequential
     * @type {?}
     */
    AngularPaginatorDirective.prototype.boundaryLinkNumbers;
    /**
     * Also displays ellipses when rotate is true and maxSize is smaller than the number of pages forceEllipses
     * @type {?}
     */
    AngularPaginatorDirective.prototype.forceEllipses;
    /**
     * Use unique id when multiple paginations are being used on the same page. By Default Paginator uses id `ANGULAR_PAGINATOR_DEFAULT`
     * @type {?}
     */
    AngularPaginatorDirective.prototype.id;
    /** @type {?} */
    AngularPaginatorDirective.prototype.currentPage;
    /** @type {?} */
    AngularPaginatorDirective.prototype.firstPage;
    /** @type {?} */
    AngularPaginatorDirective.prototype.lastPage;
    /** @type {?} */
    AngularPaginatorDirective.prototype.pages;
    /** @type {?} */
    AngularPaginatorDirective.prototype.subscription;
    /**
     * Emits an event whenever the current page is changed, It emits the current page number
     * @type {?}
     */
    AngularPaginatorDirective.prototype.pageChange;
    /** @type {?} */
    AngularPaginatorDirective.prototype._angularPaginatorService;
    /** @type {?} */
    AngularPaginatorDirective.prototype._changeDetectorRef;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1wYWdpbmF0b3IuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1wYWdpbmF0b3IvIiwic291cmNlcyI6WyJhcHAvYW5ndWxhci1wYWdpbmF0b3IvZGlyZWN0aXZlcy9hbmd1bGFyLXBhZ2luYXRvci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQXFCLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdHLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBRWhGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7Ozs7OztJQTBEN0I7Ozs7T0FJRztJQUNILG1DQUFvQix3QkFBaUQsRUFDM0Q7UUFEVixpQkFXQztRQVhtQiw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQXlCO1FBQzNELHVCQUFrQixHQUFsQixrQkFBa0I7eUJBakJoQixDQUFDO3FCQUVHLEVBQUU7NEJBRW1CLElBQUksT0FBTyxFQUFFOzs7OzBCQUtMLElBQUksWUFBWSxDQUFTLElBQUksQ0FBQzs7UUFXekUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFBLEVBQUU7WUFDbkUsSUFBSSxFQUFFLEtBQUssS0FBSSxDQUFDLEVBQUUsRUFBRTtnQkFDbEIsS0FBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2dCQUNuQixLQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDeEM7U0FDRixDQUFDLENBQUM7S0FFSjtJQUVEOztPQUVHOzs7OztJQUNILGtEQUFjOzs7O0lBQWQ7UUFDRSxJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNyQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FB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QXVCO2dCQURvQyxpQkFBaUI7OztnQ0FtQmxGLEtBQUs7aUNBSUwsS0FBSzswQkFJTCxLQUFLO3lCQUlMLEtBQUs7c0NBUUwsS0FBSztnQ0FJTCxLQUFLO3FCQUlMLEtBQUs7NkJBWUwsTUFBTTs7b0NBM0RUOztTQWNhLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgT25Jbml0LCBPbkRlc3Ryb3ksIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvYW5ndWxhci1wYWdpbmF0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBBbmd1bGFyUGFnaW5hdG9ySW5zdGFuY2UsIFBhZ2UgfSBmcm9tICcuLi9vdGhlcnMvYW5ndWxhci1wYWdpbmF0b3IuaW50ZXJmYWNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBkaXJlY3RpdmUgd2hlcmUgdGhlIGFjdHVhbCBwYWdpbmF0aW9uIHRha2VzIHBsYWNlLCBpdCBwcm92aWRlcyBhIHN5bmMgYmV0d2VlbiB0aGVcbiAqIHBpcGVzIGFuZCB0aGUgcGFnaW5hdGlvbiBjb21wb25lbnRcbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnYXBwQW5ndWxhclBhZ2luYXRvciwgW2FwcEFuZ3VsYXJQYWdpbmF0b3JdJyxcbiAgZXhwb3J0QXM6ICdhbmd1bGFyUGFnaW5hdG9yJ1xufSlcblxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJQYWdpbmF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZGlzcGxheSBGaXJzdCAvIExhc3QgYnV0dG9uc1xuICAgKi9cbiAgQElucHV0KCkgYm91bmRhcnlMaW5rczogYm9vbGVhbjtcbiAgLyoqXG4gICogV2hldGhlciB0byBkaXNwbGF5IFByZXZpb3VzIC8gTmV4dCBidXR0b25zXG4gICovXG4gIEBJbnB1dCgpIGRpcmVjdGlvbkxpbmtzOiBib29sZWFuO1xuICAvKipcbiAgICogTGltaXQgbnVtYmVyIGZvciBwYWdpbmF0aW9uIHNpemUsIGkuZS4sIHRoZSBtYXhpbXVtIHBhZ2UgbnVtYmVycyB0byBiZSBkaXNwbGF5ZWRcbiAgICovXG4gIEBJbnB1dCgpIG1heFNpemU6IG51bWJlcjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8ga2VlcCBjdXJyZW50IHBhZ2UgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXG4gICAqL1xuICBASW5wdXQoKSByb3RhdGU6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFsd2F5cyBkaXNwbGF5IHRoZSBmaXJzdCBhbmQgbGFzdCBwYWdlIG51bWJlcnMuXG4gICAqIElmIG1heC1zaXplIGlzIHNtYWxsZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHBhZ2VzLCB0aGVuIHRoZSBmaXJzdCBhbmQgbGFzdCBwYWdlIG51bWJlcnMgYXJlIHN0aWxsIHNob3duIHdpdGggZWxsaXBzZXNcbiAgICogaW4tYmV0d2VlbiBhcyBuZWNlc3NhcnkuIE5PVEU6IG1heC1zaXplIHJlZmVycyB0byB0aGUgY2VudGVyIG9mIHRoZSByYW5nZS5cbiAgICogVGhpcyBvcHRpb24gbWF5IGFkZCB1cCB0byAyIG1vcmUgbnVtYmVycyBvbiBlYWNoIHNpZGUgb2YgdGhlIGRpc3BsYXllZCByYW5nZSBmb3IgdGhlIGVuZCB2YWx1ZSBhbmRcbiAgICogd2hhdCB3b3VsZCBiZSBhbiBlbGxpcHNpcyBidXQgaXMgcmVwbGFjZWQgYnkgYSBudW1iZXIgYmVjYXVzZSBpdCBpcyBzZXF1ZW50aWFsXG4gICAqL1xuICBASW5wdXQoKSBib3VuZGFyeUxpbmtOdW1iZXJzOiBib29sZWFuO1xuICAvKipcbiAgICogQWxzbyBkaXNwbGF5cyBlbGxpcHNlcyB3aGVuIHJvdGF0ZSBpcyB0cnVlIGFuZCBtYXhTaXplIGlzIHNtYWxsZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHBhZ2VzIGZvcmNlRWxsaXBzZXNcbiAgICovXG4gIEBJbnB1dCgpIGZvcmNlRWxsaXBzZXM6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBVc2UgdW5pcXVlIGlkIHdoZW4gbXVsdGlwbGUgcGFnaW5hdGlvbnMgYXJlIGJlaW5nIHVzZWQgb24gdGhlIHNhbWUgcGFnZS4gQnkgRGVmYXVsdCBQYWdpbmF0b3IgdXNlcyBpZCBgQU5HVUxBUl9QQUdJTkFUT1JfREVGQVVMVGBcbiAgICovXG4gIEBJbnB1dCgpIGlkOiBzdHJpbmc7XG5cbiAgY3VycmVudFBhZ2U6IG51bWJlcjtcbiAgZmlyc3RQYWdlID0gMTtcbiAgbGFzdFBhZ2U6IG51bWJlcjtcbiAgcGFnZXM6IFBhZ2VbXSA9IFtdO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuZXZlciB0aGUgY3VycmVudCBwYWdlIGlzIGNoYW5nZWQsIEl0IGVtaXRzIHRoZSBjdXJyZW50IHBhZ2UgbnVtYmVyXG4gICAqL1xuICBAT3V0cHV0KCkgcGFnZUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4odHJ1ZSk7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBfYW5ndWxhclBhZ2luYXRvclNlcnZpY2Ugc2VyaXZjZSBmb3IgYW5ndWxhciBwYWdpbmF0b3JcbiAgICogQHBhcmFtIF9jaGFuZ2VEZXRlY3RvclJlZiBmb3IgbWFudWFsIGNoYW5nZSBkZXRlY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2FuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlOiBBbmd1bGFyUGFnaW5hdG9yU2VydmljZSxcbiAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcblxuICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLl9hbmd1bGFyUGFnaW5hdG9yU2VydmljZS5jaGFuZ2Uuc3Vic2NyaWJlKGlkID0+IHtcbiAgICAgIGlmIChpZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VzKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gcHJldm9pdXMgcGFnZVxuICAgKi9cbiAgdG9QcmV2aW91c1BhZ2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPiB0aGlzLmZpcnN0UGFnZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UGFnZSh0aGlzLmN1cnJlbnRQYWdlIC0gMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byBuZXh0IHBhZ2VcbiAgICovXG4gIHRvTmV4dFBhZ2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPCB0aGlzLmxhc3RQYWdlKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRQYWdlKHRoaXMuY3VycmVudFBhZ2UgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIGZpcnN0IHBhZ2VcbiAgICovXG4gIHRvRmlyc3RQYWdlKCk6IHZvaWQge1xuICAgIHRoaXMuc2V0Q3VycmVudFBhZ2UodGhpcy5maXJzdFBhZ2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byBsYXN0IHBhZ2VcbiAgICovXG4gIHRvTGFzdFBhZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5zZXRDdXJyZW50UGFnZSh0aGlzLmxhc3RQYWdlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBjdXJyZW50IHBhZ2VcbiAgICpcbiAgICogQHBhcmFtIHBhZ2UgcGFnZSBudW1iZXIgdG8gc2V0IGFzIGN1cnJlbnRQYWdlXG4gICAqL1xuICBzZXRDdXJyZW50UGFnZShwYWdlOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAocGFnZSAmJiB0aGlzLmN1cnJlbnRQYWdlICE9PSBwYWdlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYWdlID0gcGFnZTtcbiAgICAgIHRoaXMucGFnZUNoYW5nZS5lbWl0KHBhZ2UpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIHBhZ2Ugb2JqZWN0IHVzZWQgZm9yIHRlbXBsYXRlXG4gICAqXG4gICAqIEBwYXJhbSBudW1iZXIgcGFnZSBudW1iZXJcbiAgICogQHBhcmFtIHRleHQgcGFnZSBudW1iZXIsIHRleHQgdG8gYmUgZGlzcGxheWVkXG4gICAqIEBwYXJhbSBpc0FjdGl2ZSB3aGV0aGVyIHRoZSBwYWdlIGlzIGFjdGl2ZSBvciBub3QsIHRydWUgZm9yIGN1cnJlbnRQYWdlXG4gICAqL1xuICBtYWtlUGFnZShudW1iZXI6IG51bWJlciwgdGV4dDogYW55LCBpc0FjdGl2ZTogYm9vbGVhbik6IGFueSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGFjdGl2ZTogaXNBY3RpdmVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqICBjcmVhdGUgcGFnZSBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudFBhZ2UgY3VycmVudCBwYWdlIG51bWJlclxuICAgKiBAcGFyYW0gaXRlbXNQZXJQYWdlIHRvdGFsIGl0ZW1zIHBlciBwYWdlXG4gICAqIEBwYXJhbSB0b3RhbEl0ZW1zIG5vIG9mIGl0ZW1zIGZvciBwYWdpbmF0aW9uLCB1c3VhbGx5IGFycmF5IGxlbmd0aFxuICAgKi9cbiAgZ2V0UGFnZXMoY3VycmVudFBhZ2U6IG51bWJlciwgaXRlbXNQZXJQYWdlOiBudW1iZXIsIHRvdGFsSXRlbXM6IG51bWJlcik6IGFueSB7XG4gICAgY29uc3QgcGFnZXM6IGFueSA9IFtdO1xuXG4gICAgLy8gRGVmYXVsdCBwYWdlIGxpbWl0c1xuICAgIGNvbnN0IHRvdGFsUGFnZXM6IG51bWJlciA9IHRoaXMubGFzdFBhZ2UgPSBNYXRoLmNlaWwodG90YWxJdGVtcyAvIGl0ZW1zUGVyUGFnZSk7XG5cbiAgICBsZXQgc3RhcnRQYWdlID0gMTtcbiAgICBsZXQgZW5kUGFnZTogbnVtYmVyID0gdG90YWxQYWdlcztcbiAgICBjb25zdCBpc01heFNpemVkOiBib29sZWFuID0gdGhpcy5tYXhTaXplICYmIHRoaXMubWF4U2l6ZSA8IHRvdGFsUGFnZXM7XG5cbiAgICAvLyByZWNvbXB1dGUgaWYgbWF4U2l6ZVxuICAgIGlmIChpc01heFNpemVkKSB7XG5cbiAgICAgIGlmICh0aGlzLnJvdGF0ZSkge1xuXG4gICAgICAgIC8vIGN1cnJlbnQgcGFnZSBpcyBkaXNwbGF5ZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXG4gICAgICAgIHN0YXJ0UGFnZSA9IE1hdGgubWF4KGN1cnJlbnRQYWdlIC0gTWF0aC5mbG9vcih0aGlzLm1heFNpemUgLyAyKSwgMSk7XG4gICAgICAgIGVuZFBhZ2UgPSBzdGFydFBhZ2UgKyB0aGlzLm1heFNpemUgLSAxO1xuXG4gICAgICAgIC8vIEFkanVzdCBpZiBsaW1pdCBpcyBleGNlZWRlZFxuICAgICAgICBpZiAoZW5kUGFnZSA+IHRvdGFsUGFnZXMpIHtcbiAgICAgICAgICBlbmRQYWdlID0gdG90YWxQYWdlcztcbiAgICAgICAgICBzdGFydFBhZ2UgPSBlbmRQYWdlIC0gdGhpcy5tYXhTaXplICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVmlzaWJsZSBwYWdlcyBhcmUgcGFnaW5hdGVkIHdpdGggbWF4U2l6ZVxuICAgICAgICBzdGFydFBhZ2UgPSAoTWF0aC5jZWlsKGN1cnJlbnRQYWdlIC8gdGhpcy5tYXhTaXplKSAtIDEpICogdGhpcy5tYXhTaXplICsgMTtcblxuICAgICAgICAvLyBhZGp1c3QgbGFzdCBwYWdlIGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgICAgIGVuZFBhZ2UgPSBNYXRoLm1pbihzdGFydFBhZ2UgKyB0aGlzLm1heFNpemUgLSAxLCB0b3RhbFBhZ2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgcGFnZSBudW1iZXIgbGlua3NcbiAgICBmb3IgKGxldCBudW1iZXIgPSBzdGFydFBhZ2U7IG51bWJlciA8PSBlbmRQYWdlOyBudW1iZXIrKykge1xuICAgICAgY29uc3QgcGFnZSA9IHRoaXMubWFrZVBhZ2UobnVtYmVyLCBudW1iZXIsIG51bWJlciA9PT0gY3VycmVudFBhZ2UpO1xuICAgICAgcGFnZXMucHVzaChwYWdlKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbGlua3MgdG8gbW92ZSBiZXR3ZWVuIHBhZ2Ugc2V0c1xuICAgIGlmIChpc01heFNpemVkICYmIHRoaXMubWF4U2l6ZSA+IDAgJiYgKCF0aGlzLnJvdGF0ZSB8fCB0aGlzLmZvcmNlRWxsaXBzZXMgfHwgdGhpcy5ib3VuZGFyeUxpbmtOdW1iZXJzKSkge1xuICAgICAgaWYgKHN0YXJ0UGFnZSA+IDEpIHtcblxuICAgICAgICBpZiAoIXRoaXMuYm91bmRhcnlMaW5rTnVtYmVycyB8fCBzdGFydFBhZ2UgPiAzKSB7IC8vIG5lZWQgZWxsaXBzaXMgZm9yIGFsbCBvcHRpb25zIHVubGVzcyByYW5nZSBpcyB0b28gY2xvc2UgdG8gYmVnaW5uaW5nXG4gICAgICAgICAgY29uc3QgcHJldmlvdXNQYWdlU2V0ID0gdGhpcy5tYWtlUGFnZShzdGFydFBhZ2UgLSAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnVuc2hpZnQocHJldmlvdXNQYWdlU2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5TGlua051bWJlcnMpIHtcblxuICAgICAgICAgIGlmIChzdGFydFBhZ2UgPT09IDMpIHsgLy8gbmVlZCB0byByZXBsYWNlIGVsbGlwc2lzIHdoZW4gdGhlIGJ1dHRvbnMgd291bGQgYmUgc2VxdWVudGlhbFxuICAgICAgICAgICAgY29uc3Qgc2Vjb25kUGFnZUxpbmsgPSB0aGlzLm1ha2VQYWdlKDIsICcyJywgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMudW5zaGlmdChzZWNvbmRQYWdlTGluayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAgY29uc3QgZmlyc3RQYWdlTGluayA9IHRoaXMubWFrZVBhZ2UoMSwgJzEnLCBmYWxzZSk7XG4gICAgICAgICAgcGFnZXMudW5zaGlmdChmaXJzdFBhZ2VMaW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kUGFnZSA8IHRvdGFsUGFnZXMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuYm91bmRhcnlMaW5rTnVtYmVycyB8fCBlbmRQYWdlIDwgdG90YWxQYWdlcyAtIDIpIHsgLy8gbmVlZCBlbGxpcHNpcyBmb3IgYWxsIG9wdGlvbnMgdW5sZXNzIHJhbmdlIGlzIHRvbyBjbG9zZSB0byBlbmRcbiAgICAgICAgICBjb25zdCBuZXh0UGFnZVNldCA9IHRoaXMubWFrZVBhZ2UoZW5kUGFnZSArIDEsICcuLi4nLCBmYWxzZSk7XG4gICAgICAgICAgcGFnZXMucHVzaChuZXh0UGFnZVNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ib3VuZGFyeUxpbmtOdW1iZXJzKSB7XG5cbiAgICAgICAgICBpZiAoZW5kUGFnZSA9PT0gdG90YWxQYWdlcyAtIDIpIHsgLy8gbmVlZCB0byByZXBsYWNlIGVsbGlwc2lzIHdoZW4gdGhlIGJ1dHRvbnMgd291bGQgYmUgc2VxdWVudGlhbFxuICAgICAgICAgICAgY29uc3Qgc2Vjb25kVG9MYXN0UGFnZUxpbmsgPSB0aGlzLm1ha2VQYWdlKHRvdGFsUGFnZXMgLSAxLCB0b3RhbFBhZ2VzIC0gMSwgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMucHVzaChzZWNvbmRUb0xhc3RQYWdlTGluayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHRoZSBsYXN0IHBhZ2VcbiAgICAgICAgICBjb25zdCBsYXN0UGFnZUxpbmsgPSB0aGlzLm1ha2VQYWdlKHRvdGFsUGFnZXMsIHRvdGFsUGFnZXMsIGZhbHNlKTtcbiAgICAgICAgICBwYWdlcy5wdXNoKGxhc3RQYWdlTGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBhZ2luYXRpb24gY29tcG9uZW50XG4gICAqL1xuICB1cGRhdGVQYWdlcygpOiB2b2lkIHtcbiAgICBjb25zdCBpbnN0YW5jZTogQW5ndWxhclBhZ2luYXRvckluc3RhbmNlID0gdGhpcy5fYW5ndWxhclBhZ2luYXRvclNlcnZpY2UuZ2V0SW5zdGFuY2UodGhpcy5pZCk7XG5cbiAgICBjb25zdCBjb3JyZWN0ZWRDdXJyZW50UGFnZSA9IHRoaXMub3V0T2ZCb3VuZENvcnJlY3Rpb24oaW5zdGFuY2UpO1xuXG4gICAgaWYgKGNvcnJlY3RlZEN1cnJlbnRQYWdlICE9PSBpbnN0YW5jZVsnY3VycmVudFBhZ2UnXSB8fCB0aGlzLmN1cnJlbnRQYWdlICE9PSBpbnN0YW5jZVsnY3VycmVudFBhZ2UnXSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UGFnZShjb3JyZWN0ZWRDdXJyZW50UGFnZSk7XG4gICAgfVxuXG4gICAgdGhpcy5wYWdlcyA9IHRoaXMuZ2V0UGFnZXMoaW5zdGFuY2UuY3VycmVudFBhZ2UsIGluc3RhbmNlLml0ZW1zUGVyUGFnZSwgaW5zdGFuY2UudG90YWxJdGVtcyk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgY3VycmVudFBhZ2UgaXMgb3V0IG9mIGJvdW5kIHdpdGggdG90YWxQYWdlc1xuICAgKlxuICAgKiBAcGFyYW0gaW5zdGFuY2UgaW5zdGFuY2UgZm9yIHdoaWNoIHRoZSByYW5nZSBpcyB0byBiZSBjb3JyZWN0ZWRcbiAgICovXG4gIG91dE9mQm91bmRDb3JyZWN0aW9uKGluc3RhbmNlOiBBbmd1bGFyUGFnaW5hdG9ySW5zdGFuY2UpOiBudW1iZXIge1xuXG4gICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGguY2VpbChpbnN0YW5jZVsndG90YWxJdGVtcyddIC8gaW5zdGFuY2VbJ2l0ZW1zUGVyUGFnZSddKTtcblxuICAgIGlmICh0b3RhbFBhZ2VzIDwgaW5zdGFuY2VbJ2N1cnJlbnRQYWdlJ10gJiYgMCA8IHRvdGFsUGFnZXMpIHtcbiAgICAgIHJldHVybiB0b3RhbFBhZ2VzO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2VbJ2N1cnJlbnRQYWdlJ10gPCAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2VbJ2N1cnJlbnRQYWdlJ107XG4gIH1cblxuICAvKipcbiAgICogY2hlY2sgaWYgdGhlcmUgaXMgYW55IGluc3RhbmNlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgaWRcbiAgICovXG4gIGlzVmFsaWRJZCgpOiB2b2lkIHtcblxuICAgIGlmICghdGhpcy5fYW5ndWxhclBhZ2luYXRvclNlcnZpY2UuZ2V0SW5zdGFuY2UodGhpcy5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gaW5zdGFuY2UgcmVnaXN0ZXJlZCB3aXRoIGlkIGAnICsgdGhpcy5pZCArICdgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5pc1ZhbGlkSWQoKTtcbiAgICB0aGlzLnVwZGF0ZVBhZ2VzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICAvKiogZGVzdHJveSB0aGUgc3Vic2NyaXB0aW9uIHdoZW4gdGhlIGRpcmVjdGl2ZSBpcyBkZXN0cm95ZWQgKi9cbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbn1cbiJdfQ==